

# 数据结构



[TOC]



# 第一章.绪论

<img src="E:\数据结构\image\绪论.png" alt="50" style="zoom:60%;" />

## 1.数据结构的基本概念

### 1.1基本概念及其术语

**数据:信息的载体**(所有能输入到计算机中,并能被计算机识别处理的符号集合,如:数,字符等)

**数据元素: 数据的基本单位 **

**数据项:构成数据元素不可分割的最小单位**

一个数据元素由若干个数据项构成

如:学生记录就是一个数据元素,它由学号,性别,姓名等数据项组成



**数据对象:具有相同性质的数据元素集合,是数据的一个子集**,如:整数的数据对象集合N={...-2,-1,0,1,2...}

**数据类型:一个值的集合和定义在此集合上一组操作的总称**,如:一个学生的结构体中,除了有学号,姓名等属性变量,还会有所定义的方法

1. **原子类型:其值不能再分的数据类型**,如:int类型

2. **结构类型:其值还能再分解为若干成分的数据类型**,如:有多个属性的结构体(类)

3. **抽象数据类型(ADT):抽象数据组织及与之相关的操作**,如:有多个属性及函数(方法)的结构体(类)

   

**数据结构:相互之间存在一种或多种特定关系的数据元素的集合**

<img src="E:\数据结构\image\1.数据结构.png" alt="50" style="zoom:38%;" />

这种数据元素之间的关系称为**结构**

**数据结构包括三方面的内容:**

1. **逻辑结构**
2. **存储结构**
3. **结构的运算**



**存储结构与逻辑结构密不可分:算法的设计取决于选定的逻辑结构,而算法的实现依赖于所采用的存储结构**



### 1.2数据结构三要素

(注:之前没有相关基础,推荐优先跳过该节,学完后再回顾这里)

#### 1.2.1逻辑结构

**逻辑结构:元素之间的逻辑关系,即从逻辑关系上描述数据,与存储无关**

**逻辑结构的分类:**

<img src="E:\数据结构\image\1.数据逻辑结构.png" alt="30" style="zoom:38%;" />

#### 1.2.2数据的存储结构

**存储结构:数据结构在计算机中的表示,也称物理结构**,它包括**数据元素的表示和关系的表示**

**主要的存储结构有:顺序存储,链式存储,散列存储**



**顺序存储:利用邻接关系体现元素之间的关系**

- **优点**:可以实现**随机存取**,每个元素占用最少的存储空间
- **缺点**:只能使用相邻的一整块存储单元,因此可能会产生较多的外部碎片

**随机存取:**当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关。例如:数组中我们可以直接通过下标找到相应的数据



**链式存储:借助指示元素的指针来表示元素之间的逻辑关系**

- **优点**:不会出现碎片现象,能充分利用所有的存储单元
- **缺点**:因为每个元素存储指针需要占用额外的存储空间,因此只能实现顺序存储



**索引存储:依靠索引表**

- **优点**:检索速度快
- **缺点**:附加的索引表额外占用空间,另外,增加和删除元素需要修改索引表,会花费较多时间



**散列存储(哈希存储):根据关键字直接计算出存储地址**

- **优点**:检索速度快
- **缺点**:若散列函数不好,则可能出现元素存储单元的冲突,而解决冲突会增加时间和空间的开销



### 1.3例题

(注:之前没有相关基础,推荐优先跳过该节,学完后再回顾这里)

1.可以用()定义一个完整的数据结构

A.数据元素  	B.数据对象	C.数据关系	D.抽象数据类型



答:D



2.非线性数据结构有那些?



答:看上述1.2.1逻辑结构



3.以下属于逻辑结构的是()

A.顺序表	B.哈希表	C.有序表	D.单链表



答:C,因为A顺序表是属于顺序存储结构,B哈希表属于散列存储结构,D单链表属于链式存储结构                                                                                                                                                                                                         



4.以下与存储结构无关的属于是()

A.循环队列	B.链表	C.哈希表	D.栈



答:D,(易错)A循环队列是用顺序表存储的队列是一种数据结构,B是链式存储结构,C是散列存储结构,而D栈是一种逻辑结构,抽象的数据类型,可采用顺序或链式的存储结构



5.在存储数据时,通常不仅要存储各元素之间的值,而且要存储()



答:数据元素之间的关系



## 2算法和算法评价

### 2.1算法的基本概念

**算法:对特定问题的求解步骤的一种表述**,它是指令的**有限序列**,其中的每条指令表示一个或多个操作

一个算法应具有以下5个特征:

1. **有穷性**:每一步都能在有穷的时间内完成
2. **确定性**:每一条指令有确切的含义
3. **可行性**:算法中描述的操作是可以通过基本运算执行有限次实现
4. **输入**:有0或多个输入
5. **输出**:有一个或多个输出

一个优秀的算法应达到:

1. **正确性**:能够正确求解问题
2. **可读性**:算法应能够正确解决问题
3. **健壮性:**输入非法数据,能够做出相应的处理
4. **高效率**,**低存储性**:算法所需的时间,空间量少



### 2.2算法效率的度量

#### 2.2.1时间复杂度

**频度**:该语句在算法中被重复执行的次数

如:i=i+1被执行一次,它的频度便为1



**时间复杂度**:算法中所有语句的频度之和,记为T(n)=O(f(n))

其中O的含义是T(n)的数量级



在分析时间复杂度时,一般将n看作无穷大,每次分析程序中,只要寻找到并列中的高阶无穷大即可



例如:

例1:

```cpp
void fun(int n){
	int i=1;
	while(i<=n)
		i=i*2;
}
```

在这个函数中,int i=1这个式子只运行一次,与之并列的while语句假设运行t次,即
$$
2^t<=n
$$
,即
$$
t=log_2n
$$
,因为有未知数n看作无穷大,比一次大得多,因此1次可省略,它的时间复杂度为
$$
O(log_2n)
$$


例2:

```cpp
void fun(int n){
	int i=0;
	whlie(i*i*i<=n)
		i++;
}
```

与上题同理,我们只需要看while语句中的执行次数,假设执行t次,即
$$
t^3<=n
$$
即
$$
^3\surd n
$$
例3:

```cpp
int m=0,i,j
for(i=1;i<=n;i++)
	for(j=1;j<=2*i;j++)
		m++;
```

执行次数有:
$$
\sum_{i=1}^n \sum_{j=1}^{2i}=\sum_{i=1}^n2i=2\sum_{i=1}^ni=n(n+1)
$$

#### 2.2.2空间复杂度

空间复杂度S(n)定义为算法所需要耗费额存储空间S(n)=O(g(n))



​																																																					<by:缥缃



# 第二章 线性表

<img src="E:\数据结构\image\2.线性表.png" style="zoom:60%;" />

## 1.线性表的定义和基本操作

### 1.1线性表的定义

**线性表:具有相同数据类型的n个数据元素的有限序列**

**表头元素:线性表中的"第一个"数据元素**

**表尾元素:线性表中"最后一个"数据元素**



**直接前驱(前驱):**线性表中一个数据元素相邻的前一项数据元素

**直接后继(后继):**线性表中一个数据元素相邻的后一项数据元素



线性表的**特点**:

- 元素个数有限
- 有先后次序
- 每个元素都是单个元素(由于元素都是数据元素)
- 每个元素占有相同的存储空间(由于数据类型相同)
- 抽象性,只讨论元素间的逻辑关系,不考虑元素的具体内容



### 1.2例题

1.线性表是具有n个()的有限序列

答:数据元素



2.以下()是一个数据元素

A.由n个实数组成的集合

B.由100个字符组成的序列

C.所有整数组成的序列

D.邻接表



答:B,注意线性表的要求特点为:相同的数据类型,有限序列



## 2.线性表的顺序表示

### 2.1顺序表的定义

**顺序表**:线性表的顺序存储

**顺序表的特点:**表中的逻辑顺序与其物理顺序相同



假设线性表L存储的起始位置为LOC(A),sizeof(ElemType)是每个数据元素所占用的存储空间大小,如图所示

![](E:\数据结构\image\线性表的顺序存储结构.jpg)



顺序表任意一个数据元素都可以**随机存取**,所以线性表的顺序存储结构是一种**随机存取的存储结构**(详见第一章的存储结构)



注:**线性表中的元素位序是从1开始的**,而**数组中的元素下标是从0开始的**



一维数组有两种分配方法:

1. 静态分配:一般是直接定义一个固定长度大小的数组,由于数组大小和空间已经固定,一旦空间占满,新的数据便会溢出导致程序崩溃,

   例如:

   ```cpp
   int arr[MaxSize];
   ```

2. 动态分配:用动态存储分配语句(malloc或new)分配,可以动态的变化数组的大小,避免了静态分配的缺点,

   例如:

   ```cpp
   #define InitSize 100 //表初始长度的定义
   typedef struct{
       ElemType* data;		//指示动态分配数组的指针
       int MaxSize,length;	//数组的最大容量和当前个数
   }SeqList;
   
   //C动态分配语句
   L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize)
       
   //c++动态分配语句
   L.data=new ElemType[InitSize]
   ```

   注:使用**动态分配并不意味着链式存储**,它仍然**属于顺序存储结构**,物理结构并没有发生变化,**依然是随机存储方式**,只是分配的空间在运行时动态决定

​	

**顺序表的特点:**

1. **最主要的特点:随机访问**,时间复杂度为O(1)
2. **存储密度高**,每个结点只存储数据元素
3. **插入和删除需要移动大量元**素,例如:在一个数组中删除一个元素,需要将该元素后面的所有元素向前移动占取删除元素的位置



### 2.2顺序表的基本操作的实现

1.**插入操作**

```cpp
bool ListInsert(SqList &L,int i,ElemType e){
	if(i<1||i>L.length+1){ //如果插入的位置不正确,注意线性表的元素位序是从1开始的
        return false;//直接返回失败
    }
    if(L.length>=MaxSize){ //如果存储空间已满
        return false;//直接返回失败
    }
    for(int j=L.length;j>=i;j--){
        L.data[j]=L.data[j-1];//将插入元素位置的元素及后续元素全部向后移动一个元素大小
    }
    L.data[i-1]=e;//注意线性表的元素位序,与数组不同
    L.length++;
    return true;
}
```



最好的情况:在表尾插入,不需要移动元素,时间复杂度为O(1)

最差的情况:在表头插入,需要移动所有元素,时间复杂度为O(n)

平均情况:平均次数为n/2,时间复杂度为O(n)



2.**删除操作**

```cpp
bool ListDelete(SqList &L,int i,ElemType &e){
	if(i<1||i>L.length) return false;
    e=L.data[i-1]; //注意线性表的元素位序与数组不同
    for(int j=i;j<L.length;j++){
        L.data[j-1]=L.data[j];//把第i个元素后的元素前移
    }
    L.length--;
    return true;
}
```



最好情况:删除表尾元素,无序移动元素,时间复杂度为O(1)

最差情况:删除表头元素,需要移动其他所有元素,时间复杂度为O(n)

平均情况: 平均次数(n-1)/2,时间复杂度为O(n)



由上述情况可知:**线性表插入和删除的时间主要浪费在移动元素上**



3.**查找操作**(按值查找,顺序查找)

```cpp
int LocateElem(SqList L,ElemType e){
	int i;
	for(int i=0;i<L.length;i++){
		if(L.data[i]==e){
			return i+1;
		}
	}
	return 0;
}
```



最好情况:查找的元素在表头,时间复杂度为O(1)

最差情况:查找的元素在表尾,需要比较n次,时间复杂度为O(n)

平均情况:平均次数为(n+1)/2,时间复杂度为O(n)



### 2.3例题

1.顺序存储的优点有那些?

答:随机访问,存储密度大



2.线性表的顺序存储结构是一种()存取的存储结构

答:随机存取



3.一个顺序表所占用的存储空间大小与()无关

A.表的长度

B.元素的存放顺序

C.元素的类型

D.元素中各字段的类型



答:B,由线性表的动态初始化公式得:

```cpp
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize)

sizeof(ElemType)*InitSize//意味着表的长度
(ElemType*)//意味着元素的类型,元素的类型又与各字段的类型相关
```

因此顺序表的存储空间大小为:表长*元素的类型



4.在一个长度为n的顺序表中删除第i个元素时,需要移动()个元素



答:需要移动n-i个元素,因为顺序表长为n,因此在第i个元素后面的元素总和为n-i个,向前移动一个位置即可,因此是n-i



5.在一个长度为n的顺序表中第i个位置插入新的元素,需要移动()个元素



答:需要移动n-i+1个元素,要在第i个位置插入新的元素,意味着要把第i个后续的所有元素(n-i)包含i(1)向后移动一个单位(n-i+1)



6.对于顺序表,访问第i个位置的元素和在第i个位置插入一个元素的时间复杂度为()



答:O(1),O(n),访问是随机存取,时间复杂度为O(1),插入和删除的时间复杂度为O(n)



7.若长度为n的非空线性表采用顺序存储结构,在表的第i个位置插入一个数据元素,则i的合法值为()

A.1<=i<=n

B.1<=i<=n+1

C.0<=i<=n-1

D.0<=i<=n



答:B,注意线性表的次序是从1开始的,长度为n,及位置有n+1个



8.从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值,空出的位置由最后一个元素填补,若顺序表为空,则显示错误并退出

```cpp
bool DelMin(Sqlist &L,ElemType &value){
	if(L.length==0) return false; //如果表为空
	value=L.data[0]; //假设0号位元素最小
	int pos=0; //记录最小值的下标
	for(int i=0;i<L.length;i++){//遍历整个顺序表
		if(L.data[i]<value){//如果第i个元素比之前记录的最小元素小
			value=L.data[i];//更新最小的元素
			pos=i;//记录最新最小元素的位置
		}
	}
	L.data[pos]=L.data[L.length-1];//填补最后一个位置
	L.length--;
	return true;
}
```



9.设计一个高效算法,将顺序表L所有的元素逆置,要求算法的空间复杂度为O(1)

```cpp
void Reverse(Sqlist &L){
	ElemType temp;//利用一个中间值交换
    for(int i=0;i<L.length/2;i++){
        temp=L.data[i];
        L.data[i]=L.data[L.length-i-1];
        L.data[L.length-i-1]=temp;
    }
}
```



10.对长度为n的顺序表L,编写一个时间复杂度为O(n),空间复杂度为O(1)的算法,该算法删除线性表中所有值为x的数据元素

```cpp
//利用两个快慢双指针解决
void delX(Sqlist &L,ElemType x){
    int k=0,i;
    for(i=0;i<L.length;i++){
        if(L.data[i]!=x){//如果快指针所指向的元素不等于x
            L.data[k]=L.data[i];//把快指针指向的元素赋值给慢指针
            k++;//移动慢指针
        }
    }
    L.length=k;//更新线性表的长度
}
```



11.从有序顺序表中删除其值在定制s到t之间(包含t和s,要求s<t)的所有元素,若s或t不合理或顺序表为空,则显示出错信息并退出运行

```cpp
bool Del_s_t(SqList &L,ElemType s,ElemType t){
	if(s>=t||L.length==0){//如果s大于t,表长为0返回false
		return false;
	}
	int i,j;
	for(i=0;i<L.length&&L.data[i]<s;i++);//找到第一个值大于或等于s的元素
	if(i>=L.length) return false;//如果在表长中没有找到大于s的值,返回false
	for(j=i;j<L.length&&L.data[j]<t;j++);//找到大于t的第一个元素
	for(;j<L.length;i++,j++){
		L.data[i]=L.data[j];//让大于t的元素占取删除元素的位置
	}
	L.length=i;//刷新表长
	return true;
	
}
```



12.从有序顺序表中删除所有值重复的值,使表中所有的值均不同

```cpp
//利用快慢指针解决
bool Delete_same(SqList &L){
	if(L.length==0) return false;//判断线性表的长度是否正确
	int i,j=0;//j为慢指针,i为快指针
	for(i=1;i<L.length;i++){//遍历
		if(L.data[i]!=L.data[j]){//如果快指针的值不等于慢指针的值 
			L.data[++j]=L.data[i];//移动快指针,并将快指针对应的元素赋值给慢指针
		}		
	}
	L.length=j+1;//更新线性表的长度
	return true;
}
```



13.将两个有序顺序表合并为一个新的有序顺序表,并返回结果顺序表(**重点**)

```cpp
bool Merge(SqList A,SqList B,SqList &C){
    if(A.length+B.length>C.maxSize) return false;//大于顺序表的最大长度
    int i=0,j=0,k=0;//三个指针,对应三个线性表
    while(i<A.length&&j<B.length){
        if(A.data[i]<=B.data[j]){
            C.data[k++]=A.data[i++];
        }else{
            C.data[k++]=b.data[j++];
        }
    }
    while(i<A.length) C.data[k++]=A.data[i++];
    while(j<B.length) C.data[k++]=A.data[j++];
    C.length=k;
    return ture;
    
}
```



##  3,线性表的链式表示

### 3,1单链表的定义

**单列表**:线性表的链式存储,指通过一组任意的存储单元来存储线性表中的数据元素

```cpp
typedef struct LNode{
	ElemType data;
	Struct LNode *next;
}LNode,*LinkList;
```

结点结构:

<img src="E:\数据结构\image\单链表结点结构.jpg" style="zoom:33%;" />

其中data为数据域,存放数据元素

next为指针域,存放后继结点的地址



**特点:**

- **优点**:
  1. **解决了顺序表的需要大量连续存储单元的缺点**
  2. **在插入和删除时不需要移动大量元素**
- **缺点**:
  1. **单链表附加指针域,存在空间浪费**
  2. **单链表是非随机存取的存储结构,不能直接找到表中某个特定的结点,找查某一特定结点时需要从表头开始遍历**



注:根据顺序表和链表的优缺点我们可以选择在特定情况下合适的结构



通常情况下,我们会选择同**头指针来标识一个单链表**.此外,为了操作方便(一般情况下是为了避免表头的特殊情况),在单链表第一个结点之前附加一个结点,称为**头结点**.

在头结点中,头结点的数据域不设任何信息,也可以用于记录表长,头结点的指针域指向线性表的第一个元素结点

带头结点的单列表:

![](E:\数据结构\image\带头结点的单链表.jpg)



**头结点与头指针的区分:**

- 头指针始终指向链表的第一个结点
- 头结点是带头结点链表的第一个结点,通常不存储信息

刚开始链表,头指针一般会指向头结点,

头结点可以不存在



**头结点带来的优点:**

1. 链表的第一个位置上的操作在表的其他位置上的操作一致,无需特殊化处理
2. 无论链表是否为空,其头指针都是指向头结点的非空指针,空表和非空表的处理得到了统一



### 3.2单链表基本操作的实现

1.**头插法建立单链表**

<img src="E:\数据结构\image\头插法建立单链表.jpg" style="zoom:67%;" />

```cpp
LinkList List_HeadInsert(LinkList &L){
    LNode* s;
    int x;
    L=(LinkList)malloc(sizeof(LNode));//创建头结点
    L->next=NULL;//初始为空链表
    scanf("%d",&x);//输入结点的值
    while(x!=9999){//输入9999表示结束
        s=(LNode*)malloc(sizeof(LNode));//创建新的结点
        s->data=x;
        s->next=L->next;
        L->next=s;
        scanf("%d",&x);
    }
    return L;
}
```



2.**尾插法建立单链表**

若需要结点的次序和输入数据的顺序一致,则使用尾插法

![](E:\数据结构\image\尾插法建立单链表.jpg)



```cpp
LinkList List_TailInsert(LinkList &L){//正向建立单链表
    int x;
    L=(LinkList)malloc(sizeof(LNode));
    LNode* s, *r=L;//r为表尾指针
    scanf("%d",&x);
    while(x!=9999){//输入9999表示结束
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;//表尾指针指向新的表尾结点
        scanf("%d",&x);                         
    }
    r->next=NULL;//尾结点置空
    return L;
}
```



3.**按序号找查结点**

从第一个结点触发,挨个向下搜索,直至找到第i个结点为止,否则返回最后一个指针域NULL

```cpp
LNode *GetElem(LinkList L,int i){
	if(i<1){
	 	return NULL;
	}
	int j=1;//计数
	LNode *p=L->next;//第一个结点指针赋值给p
	while(p!=NULL&&j<i){//从第一个结点开始找查
		p=p->next;
		j++;
	}
	return p;
}
```



4.**按值查找表结点**

从第一个结点出发,依次比较表中各结点数据域中的值,若结点数据域中的值等于e,则返回该结点的指针,若没有该节点则返回NULL

```cpp
LNode* LocateElem(LinkList L,ElemType e){
	LNode* p=L->next;
	while(p!=NULL&&p->data!=e){
		p=p->next;
	}
	return p;
}
```



5.**插入结点操作**

**及其重要**:下面的第二句,第三句位置不能调换

```cpp
p->GetElem(L,i-1);
s->next=p->next;//先将新结点的指针指向原结点指针指向的位置
p->next=s;//再将原结点指针指向新结点
```



后插操作

```cpp
s->next=p->next;
p->next=s;
temp=p->data;
p->data=s->data;
s->data=temp;
```



6.**删除结点操作**

将单链表的第i个结点删除

![](E:\数据结构\image\单链表的删除.jpg)

```cpp
p=GetElem(L,i-1);//找查删除位置的前驱节点
q=p->next;//令q指向被删除的结点
p->next=q->next;//将*p结点从链中断开
free(q);//释放存储空间
```



删除结点*p

将后继结点的值赋予自身,然后删除后继结点

```cpp
q=p->next;//令q指向*p的后继结点
p->data=p->next->data;//用后继结点的数据域覆盖
p->next=q->next;//将*p结点从链中断开
free(p);//释放后继结点的存储空间
```



7.**求表长操作**

设置一个计数器,依次遍历



### 3.3双链表

在单链表中只有一个指向后继的指针,使得单链表只能从头结点依次顺序向后遍历.而当要访问某个结点的前驱结点时,只能从头开始遍历,为克服上述缺点,我们引入了双链表,双链表结点中有两个指针prior和next分别指向其前驱结点和后继结点.



![](E:\数据结构\image\双链表示意图.jpg)



```cpp
typedef struct DNode{
	ElemType data;//数据域
	Struct DNode *prior,*next;//前驱和后继指针
}DNode,*NodeList
```



**双链表的优点**:相较于单链表双链表能够更快的找到前驱结点

**缺点:**会花费更多的空间大小



1.**双链表的插入操作**

![](E:\数据结构\image\双链表的插入操作.jpg)

```cpp
1.s->next=p->next;
2.p->next->prior=s;
3.s->prior=p->next;
4.p->next=s;
```

 

2.**双链表的删除操作**

删除*p的后继结点\*q

![](E:\数据结构\image\双链表的删除操作.jpg)

```cpp
1.p->next=q->next;
2.q->next->prior=p;
free(q);
```



### 3,4循环链表

1.**循环单链表**

循环单链表与单链表的区别:

表中的最后一个结点的指针不是NULL,而改为指向头结点,使整个链表形成一个环

 ![](E:\数据结构\image\循环单链表.jpg)



**优点**:可以从表中的任意一个结点开始遍历整个链表

有时对循环单链表不设头指针而仅设尾指针,以使得效率更高,例如:

如果只设头指针,那么在表尾插入元素的时间复杂度为O(n),但如果设的是尾指针,在表头表尾插入元素都只要O(n)个元素



2.**循环双链表**

![](E:\数据结构\image\循环双链表.png)



**如何判断*p是尾结点**:p->next=L;

**如何判断循环双链表为空表**:头结点的prior域和next域都等于L



### 3.5**静态链表**

**静态链表:**利用数组来描述线性表的链式存储结构,结点也有data(数据域)和next(指针域)

指针式结点的相对地址(数组下标),和顺序表一样,静态链表也要预先分配一块连续的内存空间

![](E:\数据结构\image\线性表的顺序存储结构.jpg)



```cpp
#define MaxSize 50//静态链表的最大长度
typedef struct{//静态链表结构类型的定义
	ElemType data;//存储数据元素
	int next;//下一个元素的数组下标
}SLinkList[MaxSize];
```



静态链表以next==-1作为其结束的标志



### 4.例题

1,关于线性表的顺序存储结构和链式存储结构的描述中,正确的是()

​	1.线性表的顺序存储结构优于其链式存储结构

​	2.链式存储结构比顺序存储结构能更方便地表示各种逻辑结构

​	3.若频繁使用插入和删除结点操作,则顺序存储结构更优于链式存储结构

​	4.顺序存储结构和链式存储都可以进行顺序存取

A.1,2,3	B.2,4	C.2,3	D.3,4



答:B,1.存储结构有好有坏

2.链式结构中可以用指针表示逻辑结构,顺序结构只能用物理的邻接关系来表示逻辑结构

3.插入和删除链式结构更优,因为顺序结构插入和删除需要移动大量元素

4.顺序存储结构既能随机存取又能顺序存取,而链式结构只能顺序存取



2.下列关于线性表说法中,正确的是()

​	1.顺序存储方式只能用于存储线性结构

​	2.取线性表中的第i个元素的时间与i的大小有关

​	3.静态链表需要分配较大的连续空间,插入和删除不需要移动元素

​	4.在一个长度为n的有序单链表中插入一个新结点并保持有序的时间复杂度为O(n)

​	5.若用单链表来表示队列,则应该选用带尾指针的循环链表

A.1,2	B.1,3,4,5	C.4,5	D.3,4,5



答:D,

1.错,顺序存储方式也能同样适合图和树

2.错,当在顺序存储结构中的线性表随机存取元素,取得元素的时间复杂度为O(1)

3.正确

4.正确,要插入一个新结点并保持有序需要先遍历找到相应大小对应的位置,因此时间复杂度为O(n)

5.正确,队列需要在表头删除元素和表尾插入元素,因此仅带尾指针的循环链表会更加方便插入和删除的时间复杂度为O(n)



3.在一个单链表中,已知q所指结点是p所指结点的前驱结点,若在q和p之间插入点s,则该如何执行?

```cpp
q->next=s;
s->next=p;
```



4.给定有n个元素的一维数组,建立一个有序单链表的最低时间复杂度是()

答:先建立好链表(O(n))再对数组进行排序(O(nlogn)



5.将长度为n的单链表链接在长度为m的单链表后面,其算法的时间复杂度为?

答:O(m)



6.在一个长度为n的带头结点的单链表h上,设有尾指针r,则执行()操作与链表的表长有关

A.删除单链表的第一个元素

B.删除单链表的最后一个元素

C.在单链表第一个元素前插入一个新元素

D.在单链表最后一个元素后插入一个新元素



答:B,删除单链表的最后一个元素需要将前置结点的指针域设为空,要找到前置结点需要从头开始依次遍历,因此与链表的长度有关





7.对于一个头指针为head的带头结点的单链表,判定该表为空表的条件是(),对于不带头结点的单链表,判定空表的条件是()

```cpp
head->next==NULL;
head==NULL
```



8.在长度为n的有序单链表中插入一个新结点,并仍然保持有序的时间复杂度是()

答:O(n),线性表需要遍历寻找到正确的位置插入,因此时间复杂度为O(n)



9.已知一个带有表头结构的双向循环链表L,其中prev和next分别是指向其直接前驱和直接后继结点的指针,先要删除指针p所指的结点,正确的语句操作是()



```cpp
p->next->prev=p->prev;
p->prev->next=p->next;
free(p);
```



10.设计一个递归算法,删除不带头结点的单链表L中所有值

```cpp
void Del_X_3(LinkList &L,ElemType x){
	LNOde* p;
	if(L==NULL) return;
	if(L->data==x){
		P=L;
		L=L->next;
		free(p);
		Del_X_3(L,x);
	}else{
          Del_X_3(L->next,x);
    }
}
```



11.在带头结点的单链表L中,删除所有值为x的 结点,并释放空间,假设值为x的结点不唯一

```cpp
void Del_X_1(LinkList &L,ElemType e){
	LNode* p=L->next,*pre=L,*q;//p表示当前指针位置,pre表示前驱的指针,q用于记录当前指针
	while(p!=NULL){
		if(p->data==x){
			q=p;//让q记录p当前的位置
			p=p->next;//更新p的位置
			pre->next=p;//更新前驱指向的结点
			free(q);
		}else{
			pre=p;//更新前驱结点
			p=p->next;//向后遍历线性表
		}
	}
}
```



12.试编写在带头结点的单链表L中删除一个最小值结点的高效算法(假设最小值结点是唯一的)

```cpp
LinkList DeleteMin(LinkList &L){
	LinkList p=L->next,pre=L,minPre=pre,min=p;
	while(p!=NULL){
		if(p->data<min->data){
			min=p;
			minPre=pre;
		}
		pre=p;
		p=p->next;
	}
    minPre->next=min->next;
    free(min);
    return L;
}
```



13.试编写算法将带头结点的单链表就地(指辅助空间复杂度为O(1))逆置

```cpp
//将头结点摘下,再按头插法顺序插入
LinkList Reverse(LinkList &L){
	LinkList p=L->next,r;//p表示当前指针,r表示后继
    L->next=NULL;//将链表的头结点断开
    while(p!=NULL){
        r=p->next;
        p->next=L->next;//插入操作
        L->next=p;
        p=r;//更新结点
    }   
    return L;
}
```



14.给定两个单链表,编写算法找出两个链表的公共结点

```cpp
//当两个链表有公共结点时,意味着链表的最后一个元素是相等的,因此我们只需要分别遍历两个单链表记录下最后一个结点,比较是否相等即可
//遍历
LinkList Ergodic(LinkList L){
	LinkList p=L->next,pre=L;
	while(p!=NULL){
		pre=p;
		p=p->next;
	}
    return pre;
}

bool SearchCommon(LinkList L1,LinkList L2){
    LinkList p1=Ergodic(L1);
    LinkList p2=Ergodic(L2);
    if(p1==p2){
        return true;
    }
    return false;
	
}
```

****



​																																																						<by:缥缃



# 第三章 栈.队列和数组

![](E:\数据结构\image\栈,队列和数组.png)

## 1.栈

### 1.1栈的基本概念

**栈:**只允许在一端进行插入或删除操作的线性表

注:栈是一种线性表

**栈顶:**线性表允许进行插入删除的那一端

**栈底:**固定的,不允许进行插入和删除的另一端.

**空栈:**不含任何元素的空表



**栈的特性:**后进后出(Last In First Out, LIFO)

**栈的数学性质:**出栈元素的不同排列顺序有:
$$
\frac{1}{n+1}C^n_{2n}
$$

<img src="E:\数据结构\image\栈的示意图.png" alt="38" style="zoom:38%;" />



**栈的基本操作:**

InitStack(&S):初始化空栈

StackEmpty(S):判断一个栈是否为空

Push(&S,x):进栈

Pop(&S,&x):出栈

GetTop(S,&x):读栈顶元素

DestroyStack(&s):销毁栈





### 1.2栈的顺序存储结构

栈是一种操作受限的顺序表

1.**顺序栈的实现**:

```cpp
#define MaxSize 50
typedef struct{
	ElemType data[MaxSize];
	int top;
}SqStack;
```



栈顶指针:S.top,初始为-1

栈顶元素:S.data[S.top]

进栈操作:栈不满时,栈顶元素指针先加1,再送值到栈顶元素

出栈操作:栈非空时,先取栈顶元素值,再将栈顶指针减1



2.**顺序表的基本运算**:

栈顶指针与栈中元素之间的关系:

<img src="E:\数据结构\image\栈顶指针与栈中元素的关系.png" alt="38" style="zoom:38%;" />

基本实现:

(1).初始化

```cpp
void InitStack(SqStack &S){
	S.top=-1;
}
```



(2)判栈空

```cpp
bool StackEmpty(SqStack &S){
	if(S.top==-1) return true;//栈空
	else return false;//不空
}
```



(3)进栈

```cpp
bool Push(SqStack &S,ElemType x)
	if(S.top==MaxSize-1) return false;
	S.data[++S.top]=x;
	return true;
}
```



(4)出栈

```cpp
bool Pop(SqStack &S ,ElemType x){
	if(S.top==-1) return false;
	x=S.data[S.top--];
	return true;
}
```



(5)读栈顶元素

```cpp
bool GetTop(SqStack &S,ElemType &x){
	if(S.top==-1) return false;
	x=S.data[S.top];
	return true;
}
```



注:若栈顶指针指向的是栈顶元素的下一个位置即S.top=0.则入栈操作应变为S.data[S.top++]==x,同理出栈操作应变为x==S.data[--S.top]



3.**共享栈**

利用栈底位置相对不变的特性,可让两个顺序栈共享一个一维数组空间,将两个栈的栈底分别设在共享空间的两端,两个栈顶向共享空间的中间延伸

<img src="E:\数据结构\image\共享栈.png" alt="38" style="zoom:38%;" />

0号栈为空:top0==-1

1号栈为空:top1==MaxSize

栈满:top1-top0=1



**共享栈的优点:**能够更有效的利用存储空间



### 1.3栈的链式存储结构

<img src="E:\数据结构\image\栈的链式存储.png" alt="38" style="zoom:38%;" />

**栈链**:采用链式存储结构的栈

**栈链的优点:**便于多个栈共享存储空间和提高其效率,并且通常情况下不会出现栈满的情况

```cpp
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}*LiStack;
```



### 1.4例题

1.()不是栈的基本操作

A. 删除栈顶元素 	B.删除栈底元素	C.判断栈是否为空	D.将栈置为空栈



答:B



2.设有一个空栈,栈顶指针为1000H,每个元素需要一个存储单元,执行Push,Push,Pop,Push,Pop,Push,Pop,Push操作后,栈顶指针的值为()



答:1002H,push会使栈顶指针扩大1,Pop会减小1,所以(1000+1+1-1+1-1+1-1+1)H



3.和顺序栈相比,链栈有一个较为明显的优势,即()



答:通常不会出现栈满的情况



4.设链表不带头结点且所有操作均在表头进行,则下列最不合适作为链栈的是()

A.只有表头结点指针,没有表尾指针的双向循环链表

B.只有表尾结点指针,没有表头指针的双向循环链表

C.只有表头结点指针,没有表尾指针的单向循环链表

D.只有表尾结点指针,没有表头指针的单向循环链表



答:C,在双向循环链表中无论表头表尾都能轻易找到表头结点,并进行插入和删除.但在单向循环链表中,尾指针可以轻易找到表头结点,但只知道头指针是却需要遍历整个链表找到尾指针



5.向一个栈顶指针为top的链栈(不带头结点)中插入一个x结点,则该如何执行?

```cpp
//类比头插法
x->next=top;
top=x;
```



6.链栈(不带头结点)执行Pop操作,并将出栈的元素存于x中,应如何执行?

```cpp
x=top->data;
top=top->next;
```



7.3个不同元素进栈,能得到几种()不同的出栈序列



答:带入公式
$$
\frac{1}{n+1}C^n_{2n}
$$
有5种



8.设a,b,c,d,e,f以所给的次序进栈,若在进栈操作时,允许出栈操作,则下面得不到的出栈顺序为()

A.fedcba 	B.bcafed 	C.dcefba	D.cabdef



答:C



9.已知一个栈的入栈顺序时1,2,3,4,其出栈序列为p1,p2,p3,p4,则p2,p4不可能是()

A.2,4	B.2,1	C.4,3	D.3,4



答:C



## 2.队列

### 2.1队列的基本概念

1.**队列的定义**

**队列:**也是一种操作受限的顺序表,只允许在表的一端进行插入,而在表的另一端删除

**队列的操作特性:**先进先出(First In First Out,FIFO)

**队头:**允许删除的一端

**队尾:**允许插入的一端



2.**队列常见的基本操作**

InitQueue(&Q):初始化队列

QueueEmpty(Q):判断队空

EnQueue(&Q,x):入队

DeQueue(&Q,&x):出队

GetQueue(&Q,&x):读队头元素



### 2,2队列的顺序存储结构

1.**队列的顺序存储**

```cpp
#define MaxSize 50//定义队列中元素的最大个数
typedef struct{
	ElemType data[MaxSize];//存放队列元素
	int front,rear;//队头元素和队尾元素
}SqQueue;
```



初始时:Q.front=Q.rear=0;

进队操作:队不满时,先送值到队尾元素,再将队尾指针+1

出队操作:队不空时,先取队头元素值,再将队头指针+1



注:不能把Q.rear==MaxSize作为队列满的条件



<img src="E:\数据结构\image\队列的操作.png" alt="38" style="zoom:38%;" />



2.**循环队列**

**循环队列:**将顺序队列臆造为一个环状的空间,即把存储队列元素的表从逻辑上视为一个环.

当队首指针Q.front=MaxSize-1后,再前进也给位置就自动到0,这可以利用除法取余运算(%)来实现



初始化:Q.front=Q.rear=0;

队首指针进1:Q.front=(Q.front+1)%MaxSize

队尾指针进1:Q.rear=(Q.rear+1)%MaxSize

**队列长度**:(Q.rear+MaxSize-Q.front)%MaxSize



**队空**:Q.front==Q.rear

由于**队满**的条件也是Q.front=Q.rear,因此有三种处理方式:

1)牺牲一个单元来区分队空队满,入队时少用一个队列单位,约定 "队头指针在队尾指针的下一个位置作为队满的标志"

<img src="E:\数据结构\image\循环队列出入队示意图.png" style="zoom:38%;" />

队满:(Q.rear+1)%MaxSize==Q.front

队空条件:Q.front==Q.rear

队列中的元素个数:(Q.rear-Q.front+MaxSize)%MaxSize



2)类型中增设表示元素个数的成员

队空:Q,size==0;

队满:Q.size==MaxSize;



3)类型中增设tag数据成员,以区分是队满还是队空.

队空:tag==0

队满:tag==1



3.**循环队列的操作**

(1)初始化

```cpp
void InitQueue(SqQueue &Q){
	Q.rear=Q.front=0;
}
```



(2)判队空

```cpp
bool isEmpty(SqQueue &Q){
	if(Q.rear==Q.front) return true;
	else return false;
}
```



(3)入队

```cpp
bool EnQueue(SqQueue &Q,ElemType x){
	if((Q.rear+1)%MaxSize==Q.front) return false;
	Q,data[Q.rear]=x;
	Q.rear=(Q.rear+1)%MaxSize;
	return true;
}
```



(4)出队

```cpp
bool DeQueue(SqQueue &Q,ElemType &x){
	if(Q.rear==Q.front) return false;
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;
}
```



2.3**队列的链式存储结构**

**链队列**:队列的链式表示,它同时带有队头指针和队尾指针的单链表

<img src="E:\数据结构\image\不带头结点的链式队列.png" style="zoom:38%;" />

这是不带头结点的链式队列

```cpp
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNOde;
typedef struct{
	LinkNode *front,*rear;
}*LinkQueue;
```



队列为空:Q.front==NULL且Q.rear==NULL

**链队列的优点**:便于多个队列共享存储空间和提高效率,不会出现溢出的问题



(1)初始化:

```cpp
void InitQueue(LinkQueue &Q){
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode);
	Q.front->next=NULL;
}
```



(2)判队空

```cpp
bool IsEmpty(LinkQueue Q){
	if(Q.front==Q.rear) return true;
	else return false;
}
```



(3)入队

```cpp
void EnQueue(LinkNode &Q,ElemType x){
	LinkNode *s=(LinkNode*)malloc(sizeof(LinkNode));
	s->data=x;
	s->next=NULL;
	Q.rear->next=s;
	Q.rear=s;
}
```



(4)出队

```cpp
bool DeQueue(LinkQueue &Q,ElemType &x){
	if(Q.front==Q.rear) return false;
	LinkNode *p=Q.front->next;
	x=p->data;
	Q.front->next=p->next;
	if(Q.rear==p){
		Q.rear=Q.front;
	}
	free(p);
	return true;
}
```



### 2.3双端队列

**双端队列**:指允许两端都可以进行入队和出队操作的序列

<img src="E:\数据结构\image\双端队列.png" style="zoom:38%;" />

当对双端队列的某一端的输入和输出限制时,便能得到**输入受限的双端队列**和**输出受限的双端队列**

输入受限的双端队列:

<img src="E:\数据结构\image\输入受限的双端队列.png" alt="3" style="zoom:38%;" />

输出受限的双端队列:

<img src="E:\数据结构\image\输出受限的双端队列.png" style="zoom:38%;" />



<img src="E:\数据结构\image\双端队列例子.png" style="zoom:60%;" />

###  2.4例题

1.一个队列的入队顺序是1,2,3,4,则出队顺序是()

答:1,2,3,4



2.循环队列存储在数组A[0...n]中,入队时的操作为()

答:rear=(rear+1)%(n+1),注意是n+1,而不是n,因为它有n+1的最大容量



3.已知循环队列的存储空间为数组A[21],front指向对头元素的前一个位置,rear指向队尾元素,假设当前front和rear的值分别为8和3,则该队的长度为()

答:16,代入(Q.rear-Q.fronty+MaxSize)%MaxSize得到

注:A[n]的长度为n-1,而不是n



4.若用数组A[0...5]来实现循环队列,且当前rear和front的值分别为1和5,当从此队列中删除一个元素,再加入两个元素后,rear和front的值分别为多少()

答:3,0,先删除一个元素front=(5+1)%6=0,加入两个元素rear=(1+1)%6=2,rear=(2+1)%6=3



## 3.栈和队列的应用

### 3.1栈的运用

**栈的运用**:

1. 括号匹配
2. 表达式求值
3. 递归



### 3.2队列的运用

**队列的运用**:

1. 层序遍历
2. 计算机系统,如:打印机,CPU



## 4.数组和特殊矩阵

### 4.1数组

**数组**:由n个相同类型的数据元素构成的有限序列



**数组的存储结构:**

<img src="E:\数据结构\image\数组的存储结构.png" style="zoom:38%;" />



### 4.2特殊矩阵的压缩存储

**压缩存储:**指为多个值相同的元素只分配一个存储空间,对零元素不分配存储空间,**其目的**是为了节省存储空间

**特殊矩阵:**指具有许多相同矩阵元素或者零元素,并且这些相同的矩阵元素或零元素分布有一定的规律的矩阵,**常见的特殊矩阵有:**对症矩阵,上(下)三角矩阵,对角矩阵等

**特殊矩阵的压缩方法:**找出特殊矩阵中值相同矩阵元素的分布规律,把那些呈现规律性分布的,值相同的多个矩阵元素压缩存储到一个存储空间中



1.**对称矩阵**

<img src="E:\数据结构\image\对称矩阵.png" style="zoom:38%;" />

<img src="E:\数据结构\image\对称矩阵2.png" style="zoom:38%;" />



2.**三角矩阵**

<img src="E:\数据结构\image\三角矩阵.png" style="zoom:38%;" />

<img src="E:\数据结构\image\三角矩阵2.png" style="zoom:38%;" />



3.**三对角矩阵**

<img src="E:\数据结构\image\三对角矩阵.png" style="zoom:38%;" />



### 4.3稀疏矩阵

<img src="E:\数据结构\image\稀疏矩阵.png" style="zoom:38%;" />

压缩存储稀疏矩阵可以用三元组,也可以用十字链表



​																																																					<by:缥缃



# 第五章 树与二叉树

![](E:\数据结构\image\树与二叉树.png)

## 1.树的基本概念

**树:**n个结点的有限集.树是一种递归的数据结构,树作为一种逻辑结构,同时也是一种分层结构

**树的特点:**

1. 树的根结点没有前驱,除根结点外所有结点有且仅有一个前驱
2. 树中所有结点都可以有零个或多个后继



树的树形表示:

<img src="E:\数据结构\image\树的树形表示.png" style="zoom:38%;" />

例如在图中的结点K中.根A到结点K的唯一路径上的任意结点,称为结点K的**祖先**.就像结点B是结点K的祖先,而结点K是结点B的**子孙**.路径上最接近结点K的结点E是K的**双亲**,而K是E的**孩子**.有相同双亲的结点称为**兄弟**,例如K和L是兄弟



**结点的度:**树中一个结点的孩子个数

**度:**树中结点最大度数

例如:在上图中,B的度数为2,整个树的度数为3



**叶结点:**度为0(没有子女结点)的结点



**结点的层次:**由根节点开始为第一层,子节点为第二层,依次类推

**结点的深度:**同样从根节点开始自顶向下逐层累加

**结点的高度:**是从叶节点开始自底向下逐层累加



**有序树:**树中结点的各子树从左到右是有次序的,不能互换

**无序树:**与有序树相反的树



**路径:**两结点中存在边可达.树中两结点之间的路径是由这两个结点之间所经过的结点序列构成的

**路径长度:**路径上所经过的边的个数

**注:**树中的分支是有向的,是从双亲指向孩子,所以树中的路径是从上到下的,即同一双亲的两个孩子之间不存在路径



**森林**:m棵互不相交的树的集合

**注:**把树的根节点删掉就成了森林,反之给m棵独立的树加上一个结点,并把这m棵树作为该结点的子树,则森林就变成了树



**树的性质:**

1. **树中的结点数等于所有结点的度数之和加1**

   理由如下:由度的定义可知,假设一个结点的度为n意味着这个结点有n个孩子,那么将这些孩子累加就能得到除根结点外所有结点的个数,那么再加上根结点就等于树中的结点数

2. **度为m的树中第i层上至多有**
   $$
   m^{i-1}
   $$
   **个结点**

   理由如下:要使度为m的树中第i层的结点最多,就意味第i-1层上每个结点的度都要最大,即全部为树的度m,它的子结点会最多,即第i层结点数最多,由此类推要实现最大,则使根节点开始每一层按m个结点等比递增,得到等比公式
   $$
   a_i=a_1*q^{i-1}=1*m^{i-1}=m^{i-1}
   $$

3. **高度为h的m叉树至多有**
   $$
   (m^h-1)(m-1)
   $$
   **个结点**

   理由如下:有第2条性质可知每一层最多的结点 ,因此将每一层最多的结点累加起来,由等比数列的累加公式即得

4. **具有n个结点的m叉树的最小高度为**
   $$
   \lceil log_m(n(m-1))+1 \rceil
   $$
   理由如下:由性质3可知
   $$
   (m^h-1)(m-1)=n
   $$
   化简即能得到本公式



### 1.1例题

1.一颗有n个结点的树的所有结点的度数之和为()

答:n-1,由性质1可知



2.度为4,高度为h的树,()

A.至少由h+3个结点	B.至多由4h-1个结点	C.至多有4h个结点	D.至少有h+4个结点



答:A,要使结点最少,即h-1层的结点有4个度,其他结点的度均为最小即为1,所以最小结点数为
$$
(h-1)+4=h+3
$$
即A正确,B,C中带入性质3的公式可得
$$
(m^h-1)(m-1)=3(4^h-1)
$$


3.对于一棵具有n个结点,度为4的树来说,()

A.树的高度至多为n-3	B,树的高度至多为n-4	C.第i层上至多有4(i-1)个结点	D.至少在某一层上正好有4个结点



答:A,在A,B中与上题类似,要高度至多,呢么意味着叶结点的个数等于度数等于4,其他每一层的结点个数均为1,即高度至多有(n-4)加上最后一层,即(n-3),C由性质1可知错误,D中要注意树的度的定义,度为4只意味着某个结点的孩子有4个结点



4.假定一棵度为3的树中,结点树为50,则其最小高度为()

答:5,由性质4可得



## 2.二叉树的概念

### 2.1二叉树的定义及其主要特性

**二叉树的定义**

二叉树:一种特殊的树形结构,**其特点是**每个结点至多只有两个子树,且子树之间有左右之分,不能颠倒

二叉树的五种形态:

<img src="E:\数据结构\image\二叉树的五种形态.png" style="zoom:38%;" />



**特殊二叉树:**

1. **满二叉树**

   一棵高度为h,且含有
   $$
   2^h-1
   $$
   个结点的二叉树,如图所示:

   <img src="E:\数据结构\image\满二叉树.png" style="zoom:38%;" />

2. **完全二叉树**

   高度为h,有n个结点的二叉树,当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应,如图所示:

   <img src="E:\数据结构\image\完全二叉树.png" style="zoom:38%;" />

   **完全二叉树的特点:**

   (1)若
   $$
   i\leq\lfloor n/2 \rfloor
   $$
   则结点i是分支结点或者是叶结点

   (2)叶节点只会在层次最大的两层出现

   (3)若度为1的结点有且仅有一个,那该结点只有左孩子无右孩子
   (4)按层序编号后,一旦出现某结点i只有左孩子或者是叶节点时,则编号大于i的结点均为叶结点

   

   **完全二叉树的性质:**

   (1)当i>1时,i为偶数时,它的双亲编号为i/2,它为左孩子,i为奇数时,它的双亲编号为(i-1)/2,它为右孩子

   (2)当2i<=n时,结点i的左孩子为2i,当2i+1<=n时,结点i的右孩子为2i+1

   (3)结点i所在的深度为
   $$
   \lfloor log_2i \rfloor+1
   $$

3. **二叉排序树**:左子树上所有结点的关键字均小于根结点的关键字;右子树所有结点的关键字均大于根结点的关键字,其左右子树又格式一颗二叉排序树

4. **平衡二叉树:**树上任意一个结点的左子树和右子树深度之差不超过1



**二叉树的性质:**

1. (**重要**)非空二叉树上的叶结点数等于度为2的结点数加1,即
   $$
   n_0=n_2+1
   $$
   证明如下:设度为0,1和2的结点个数均为
   $$
   n_0,n_1,n_2
   $$
   结点总数为
   $$
   n=n_0+n_1+n_2
   $$
   设二叉树的分支总数为B,不难发现:
   $$
   n=B+1
   $$
   而在分支总数中,度为1的结点提供对应的一个分支,度为2的结点提供对应的两个分支,即
   $$
   B=n_1+2n_2
   $$
   联立即得

2. (**重要**)非空二叉树上第k层上至多有
   $$
   2^{k-1}
   $$
   个结点,与树的性质2相同

3. (**重要**)高度为h的二叉树至多有
   $$
   2^h-1
   $$
   个结点,与树的性质3相同



### 2.2二叉树的存储结构

#### 2.2.1二叉树的顺序存储结构

**二叉树的顺序存储结构**:用一组地址连续的存储单元依次自上向下,自左到右存储完全二叉树的结点元素

完全二叉树和满二叉树更适合采用顺序存储



用数组下标反应二叉树中结点之间的逻辑关系:

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" style="zoom:38%;" />

注:一般从数组下标1开始存储树中的结点



#### 2.2.2二叉树的链式存储结构

由于顺序存储结构空间利用率较低,因此我们多使用链式存储结构

在链式存储结构中,我们通常用二叉链表来表示:数据域(Data),左指针域(lchild),右指针域(rchild)

```cpp
typedef struct BiTNode{
	ElemType data;
	struct BiTNode* lchild,*rchild;
}BiTNode,*BiTree;
```



<img src="E:\数据结构\image\二叉树的链式存储结构.png" style="zoom:38%;" />



## 3.二叉树的遍历与线索二叉树

**二叉树的遍历:**按某条搜索路径访问树中每个结点,使得每个结点均被访问一次,而且仅被访问一次



### 3.1先序遍历(根->左->右)

**先序遍历的操作过程:**

1. 访问根节点
2. 先序遍历左子树
3. 先序遍历右子树



```cpp
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);//访问根结点
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}
```



### 3.2中序遍历(左->根->右)

**中序遍历的操作过程**:

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树



```cpp
void InOrder(BiTree T){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
```



### 3.3后序遍历(左->右->根)

**后序遍历的操作过程:**

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点



```cpp
void PostOrder(BiTree T){
	if(T!=NULL){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```



### 3.4先,中,后三种遍历方式的总结

三种遍历方式,都是递归遍历左右子树,但访问根结点的顺序不同

三种遍历方式,每个结点均只访问一次,因此**时间复杂度为O(n)**,递归工作**栈的深度为树的深度**,最坏情况下是,有n个结点且深度为n的单支树



非递归版本,借助栈来遍历:

以中序遍历为例

```cpp
void InOrder2(BiTree T){
	InitStack(S);//初始化栈
	BiTree p=T;//p是遍历指针
	while(p||!IsEmpty(S)){//若栈不空或p所指的结点不空
		if(p){//如果p所指结点不空,一路向左
			Push(S,p);//当前结点入栈
			p=p->lchild;//向左走
		}else{
			Pop(S,p);//栈顶元素出栈
			visit(p);//访问出栈结点
			p=p->rchild;//向右走
		}
	}
}
```



遍历该图的次序:

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" alt="3" style="zoom:38%;" />

先序遍历的次序是?  

答:

1. 先访问根,即1;
2. 然后访问1的左子树,访问左子树的根,即2;
3. 访问2的左子树,但左子树不存在,访问2的右子树,访问右子树的根,即4
4. 访问4的左子树,即6
5. 再访问4的右子树不存在,发现1左子树的所有结点均访问完毕,访问1的右子树的根,即3
6. 访问3的左子树不存在,然后访问3的右子树,即5
7. 所以最后顺序是1,2,4,6,3,5





中序遍历的次序是?

答:

1. 先访问1的左子树是以2为根;
2. 再访问2的左子树,不存在,访问2这个子树的结点,即2;
3. 访问2的右子树是以4为根,访问4的左子树,即6;
4. 访问4这个子树的根结点,即4;
5. 访问4的右子树,不存在;
6. 发现1的左子树遍历完毕,访问1的根,即1
7. 访问1的右子树.....
8. 最后的顺序是2,6,4,1,3,5





后序遍历的次序是?

答:6,4,2,5,3,1



### 3.5层序遍历

需要借助一个队列,与之后的广度优先搜索算法类似

遍历次序便是从左到右,从上到下遍历结点

像上图的遍历次序是:1,2,3,4,5,6



注:二叉排序树,利用层序遍历,逆层序遍历就能得到升序和降序



```cpp
void LevelOrder(BiTree T){
	InitQueue(Q);//初始化辅助队列
	BiTree p;
	EnQueue(Q,T)//根节点入队
	while(!IsEmpty(Q)){//如果队列不空
		DeQueue(Q,p);//出队
		visit(p);//访问出队结点
		if(p->lchild!=NULL) EnQueue(Q,p->lchild);//如果左子树不空,将左子树根加进队列
		if(p->rchild!=NULL) EnQueue(Q,p->rchild);//如果右子树不空,将右子树根加进队列
	}
}
```



### 3.6由遍历序列构造二叉树

已知遍历序列是能构造出二叉树的,但有一定条件限制:

由之前的二叉树遍历次序,可知

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" style="zoom:38%;" />

先序遍历:1,2,4,6,3,5

中序遍历:2,6,4,1,3,5

后序遍历:6,4,2,5,3,1



发现:

**在先序遍历中**,第一个结点一定是根结点,后序结点是左右子树的序列

**在后序遍历中**,最后一个结点一定是根结点,前面结点是左右子树的序列

我们单独根据先序遍历和后序遍历是无法弄清后序左右子树的排列顺序

**在中序遍历中**,根节点必然将整个序列分割成左右子树序列

中序遍历的特点正好弥补了先序和后序中未知左右子树排列顺序的缺点

因此,**只要已知先序遍历和后序遍历的其中一个序列,再已知中序遍历序列,就能构造出二叉树**



注:**一定会需要中序遍历**



例如已知先序(ABCDEFGHI),中序(BCAEDGHFI)

<img src="E:\数据结构\image\已知序列构造二叉树.png" style="zoom:38%;" />



### 3.7线索二叉树

在传统二叉树中,某一些结点只有左孩子而没有右孩子(也有可能相反),因此会空余出来相应的指针域,为了充分利用这些指针域(空间),我们构造了线索二叉树,将这些指针域用于存放指向前驱和后继的指针

**引入线索二叉树的目的:**节省空间,加快查找结点前驱和后继的速度



**线索二叉树的规定:**若无左子树,令lchild指向其前驱结点,若无右子树,令rchild指向后继结点.同时我们增加了两个标志域标识指针域

如图所示:

<img src="E:\数据结构\image\线索二叉树的结点结构.png" style="zoom:38%;" />

其标志域的含义为:

当ltag为0时表示lchild指向的是左孩子,ltag=1时,表示的是lchild指向的是前驱

当rtag为0时表示rchild指向的是右孩子,rtag=1时,表示的是rchild指向的是后继



```cpp
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode* lchild,*rchild;
	int ltag,rtag;
}TreadNOde,*TreadTree;
```



#### 3.7.1中序线索二叉树的构造

<img src="E:\数据结构\image\中序线索二叉树及其二叉链的表示.png" style="zoom:38%;" />

已知如图所示的二叉树,通过中序遍历得到序列为:B,D,A,E,C

发现B没有左子树,也没有前驱,因此不需要线索化,同理C,没有右子树,没有后继,不需要线索化

D没有左子树,前驱是B,所以D的lchild指向B,D没有右子树,后继是A,所以D的rchild指向A

E同理



中序遍历的二叉树线索化算法:

```cpp
void InThread(ThreadTree &p,ThreadTree &pre){
	if(p!=NULL){
		InThread(p->lchild,pre);//递归,线索化左子树
		if(p->lchild==NULL){//如果左子树为空
			p->lchild=pre;//指向前驱
			p->ltag=1;//刷新标志域
		}
		if(pre!=NULL&&pre->rchild==NULL){//如果右子树为空
			pre->rchild=p;//指向后继
			pre->rtag=1;//刷新标志域
		}
	}
}
```



中序遍历建立中序线索二叉树的主过程算法如下:

```cpp
void CreateInThread(ThreadTree T){
	ThreadTree pre=NULL;
	if(T!=NULL){//非空二叉树,线索化
		InThread(T,pre); //线索化
		pre->rchild=NULL;//处理遍历的最后一个结点
		pre->rtag=1;
	}
}
```



#### 3.7.2中序二叉树的遍历

求中序线索二叉树的第一个结点:

```cpp
TreadNode *FirstNode(ThreadNode *p){
	while(p->ltag==0) p=p->lchild;
	return p;
}
```



求中序线索二叉树结点p在中序序列下的后继:

```cpp
ThreadNode* Nextnode(ThreadNode* p){
	if(p->rtag==0) return FirstNode(p->rchild);
	else return p->rchlid;
}
```



#### 3.7.3先序线索二叉树和后序线索二叉树

根据遍历次序决定前驱和后继

后序线索二叉树较为复杂,可以用带标志域的三叉链表作为存储结构



## 4.树和森林

### 4.1树的存储结构

1. **双亲表示法**

​		利用一组连续空间来存储每个结点,同时在每个结点增设一个伪指针指向双亲结点所在的位置

<img src="E:\数据结构\image\双亲表示法.png" style="zoom:38%;" />



```cpp
#define MAX_TREE_SIZE 100 //树中最多结点数
typedef struct{
	ElemType data;//数据元素
	int parent;//双亲位置域
}PTNode;
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int n;//结点数
}PTree;
```

优点:可以很快的得到结点的双亲结点

缺点:求结点的孩子需要遍历整个结构



​	2.**孩子表示法**

将每个结点的孩子结点都用单链表连接起来,形成一个线性结构,此时n个结点就有n个孩子链表

<img src="E:\数据结构\image\孩子表示法.png" style="zoom:38%;" />

优点:能够快速找到孩子结点

缺点:找结点的双亲时需遍历整个数组

​	

​	3.**孩子兄弟表示法(二叉树表示法)**

用二叉链表作为树的存储结构,每个结点包括三部分:结点值,指向结点的第一个孩子的指针,指向结点下一个兄弟结点的指针

```cpp
typedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

优点:可以方便的实现树转化为二叉树的操作,易于找查结点的孩子

缺点:找查双亲比较麻烦

若每个结点增设一个parent域指向父结点,则找查父结点也将变得方便

<img src="E:\数据结构\image\孩子兄弟表示法.png" style="zoom:38%;" />



### 4.2树,森林和二叉树的转换

树转换为二叉树的规则:**左孩子右兄弟**,将每个结点的左指针指向它的第一个孩子,右指针指向它在树中相邻的右兄弟

注:由于根结点没有兄弟,所以对应的二叉树没有右子树

<img src="E:\数据结构\image\树转化成二叉树.png" style="zoom:38%;" />

森林转化成二叉树与之类似,将每个根节点看作兄弟,**一样执行左孩子右兄弟原则**

<img src="E:\数据结构\image\森林转化成二叉树.png" style="zoom:38%;" />



### 4.3树和森林的遍历

树的遍历方式:

1. **先根遍历:**若树非空,先访问根结点,再一次访问根结点的每个子树,然后同理遍历子树,其遍历次序与对应二叉树的先序遍历次序相同
2. **后根遍历:**若树非空,先遍历根节点的每个子树,再访问根节点,同理遍历子树,其遍历次序与对应的二叉树中序遍历相同



森林的遍历方式:

1. 先序遍历森林
   - 访问森林中第一棵树的根结点
   - 先序遍历第一棵树中根结点的子树森林
   - 先序遍历出去第一棵树之后剩余的树构成的森林
2. 中序遍历森林
   - 中序遍历森林中第一棵树的根结点的子树森林
   - 访问第一棵树的根结点
   - 中序遍历除去第一棵树之后剩余的树构成的森林



## 5.树和二叉树的应用

### 5.1哈夫曼树和哈夫曼编码

**哈夫曼树的定义**

**权:**树中结点被赋予表示某种意义的数值

**结点的带权路径长度:**从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积

**树的带权路径长度:**树中所有叶结点的带权路径长度之和,记为
$$
WPL=\sum^n_{i=1}w_il_i
$$
**哈夫曼树(最优二叉树):**在含有n个带权叶结点的二叉树中,WPL最小的二叉树

<img src="E:\数据结构\image\哈夫曼树.png" style="zoom:38%;" />



**哈夫曼树的构造**

1. 构造一个新结点
2. 在n个结点中找出权值最小的两个结点,分别作为新结点的左右子树,并将两个结点的权值之和赋值给新结点
3. 把新结点并入原来剩下的结点中,重复操作,直至剩下的结点数为0

<img src="E:\数据结构\image\哈夫曼树的构造.png" style="zoom:38%;" />

**哈夫曼编码**

**固定长度编码:**每个字符用相等长度的二进制位来表示

**可变长度编码:**允许对不同字符用不等长的二进制位表示



**可变长度编码相对固定长度编码的特点:**对频率高的字符赋以短编码,而频率低的赋以长编码,从而减少平均编码长度,起到压缩的效果



**前缀编码:**若没有一个编码是另一个编码的前缀

前缀编码是为了避免二义性,例如,假设A的编码是0,B的编码是00,输入00编码,无法识别它是两个A还是一个B



**哈夫曼编码**:根据哈夫曼树中结点权值出现的比例,对结点权值进行的编码

一般情况下,层数越小越容易出现比较,因此哈夫曼编码的大小随着层数的递增而递增



### 5.2并查集

**并查集**:用于处理一些不相交集合的合并及查询问题（即所谓的并、查）的树结构

一般用树的双亲表示法作为存储结构



并查集的结构:

```cpp
#define SIZE 100
int UFSets[SIZE];//集合元素数组
```

初始化操作:

```cpp
void Initial(int S[]){
	for(int i=0;i<SIZE;i++){
		S[i]=-1;
	}
}
```

Find操作:

```cpp
int Find(int S[],int x){
	while(S[x]>=0) x=S[x];
	return x;
}
```

Union操作:

```cpp
void Union(int S[],int Root1,int Root2){
	if(Root1==Root2) return;
	S[Root2]=Root1;
}
```



​																																																					<by:缥缃



# 第六章 图

<img src="E:\数据结构\image\图.png" style="zoom:38%;" />

## 1.图的基本概念

### 1.1图的定义

图G有顶点集V和边集E组成,记为G=(V,E),其中V(G)表示图中顶点的有限非空集;E(G)表示图G中顶点之间的关系(边)集合



注:图不能为空图,即图的顶点集V一定非空,E可以为空



**有向图:**E是有向边(弧)的有限集合时的图

弧是顶点的有序对,记为<v,w>,其中v为弧尾,w为弧头

总结:在图中看到边全部有箭头指明方向就是有向图



**无向图:**E是无向边的有限集合时的图

总结:在图中看到边没有箭头就是无向图



**简单图:**在一个图中满足:

1. 不存在重复边
2. 不存在自身到自身的边

的图,与之相反的是**多重图**,一般情况下,图都是简单图

总结,在图中没有出现可以省略不画的边叫简单图



**完全图(简单完全图):**有n(n-1)/2条边的**无向图**
$$
C^2_n=n(n-1)/2
$$
总结,在无向图中 ,让每两个顶点都有一条连接的边的图,即满足上述公式

**注:一定是在无向图中**



**子图:**顶点集是另一个图中顶点集的子集,边集是另一个图中边集的子集的图

总结:类比与子集



**连通:**两顶点间有路径存在(可以从一个顶点到达另一个顶点,不一定要直接相连,可间接)

**连通图:**图中任意两个顶点都是连通的图(图中随便挑两个顶点都可以从一个顶点到达另一个顶点)

**非连通图:**不满足连通图的图

**连通分量:**无向图中的极大连通子图(即该**连通子图**需要**包含图中所有的边**)

**连通图的生成树:**包含图中所有顶点的极小连通子图(即该**连通子图**需要包含**图中边数最小的边**)

注:

1. 假设一个图有n个顶点,如果边数小于n-1,那么此图一定是非连通图(因为,要使任意两个顶点连通且边数最小需要n-1条边,类比于顶点与边围成一个圆,再删去一条边)
2. **一定是在无向图中**



**强连通图:**在有向图中,任意两个顶点v和w,两者之间可互相到达(有方向),有路径的图

**强连通分量:**有向图中的极大强连通子图

注:**一定是在有向图中**



**度**:依附于顶点v的边的条数(即连在结点v上的边有几条)

根据定义,我们可以知道在无向图中,一条边影响着两个顶点,会出现两个度,因此在一个有e条边无向图中,图的度数之和为2e,即**无向图中全部顶点度数的和等于边数的两倍**

在**有向图中,图的度分为入度和出度**

**入度**:以顶点为终点的有向边的数目(箭头指向这个顶点的边)

**出度:**以顶点为起点的有向边的数目(箭头离开这个顶点的边)

度=入度+出度



**权**:每条边标上具有某种含义的数值

**带权图(网):** 边上带有权值的图



**稠密图:**边数很多的图

**稀疏图:**边数很少的图



**路径:**两顶点之间有可达的边

**路径长度:**路径上边的数目

**简单路径:**顶点不重复出现的路径

**距离:**两顶点之间的最短路径

**有向树:**一个顶点入度为0,其余顶点入度均为1的有向图



### 1.2图的存储及基本操作

图的存储必须要完整,准确地反应顶点集和边集的信息

#### 1.2.1邻接矩阵法

**邻接矩阵存储:**用一个一维数组存储图中顶点的信息,用一个二维数组存储图中边的信息,存储顶点间邻接关系的二维数组称为**邻接矩阵**

<img src="E:\数据结构\image\邻接矩阵的表示.png" style="zoom:38%;" />

```cpp
#define MaxVertexNum 100
typedef char VertexType;//顶点的数据类型
typedef int EdgeType;//权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];//顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵
	int vexnum,arcnum;//顶点数和弧数
}MGraph
```

<img src="E:\数据结构\image\各种图的邻接矩阵.png" style="zoom:38%;" />

**邻接矩阵的特点:**

1. 无向图中,邻接矩阵一定是一个对称矩阵,因此在实际中只需要存储三角矩阵元素
2. 无向图中,邻接矩阵的第i行的非零元素之和恰好是i的度
3. 有向图中,邻接矩阵的第i行的非零元素之和恰好是i的出度,第i列的非零元素之和恰好是i的入度
4. 邻接矩阵存储图,能够容易地确定两顶点间是否有边相连,但要确定有多少边需要对每个元素进行检测
5. 稠密图适合邻接矩阵的存储表示



#### 1.2.2邻接表法

当图为稀疏图时,使用邻接矩阵会浪费大量空间,而邻接表法结合顺序存储和链式存储方法,大大减小了浪费

邻接表示法的结点结构:

<img src="E:\数据结构\image\邻接表示法的结点结构.png" style="zoom:38%;" />

无向图的邻接表示法:

<img src="E:\数据结构\image\无向图的邻接表示法.png" style="zoom:38%;" />

有向图的邻接表示法:

<img src="E:\数据结构\image\有向图的邻接表示法.png" style="zoom:38%;" />



```cpp
#define MaxVertexNum 100//图中顶点数目的最大值
typedef struct ArcNode{//边表结点
	int adjvex;//该弧所指向的顶点的位置
	struct ArcNode* next;//指向下一条弧的指针
}ArcNode;

typedef struct VNode{//顶点表结点
	VertexType data;//顶点信息
	ArcNode *first;//指向第一条依附该顶点的弧的指针
}VNode,AdjList[MaxVertexNum];

typedef struct {
	AdList vertices;//邻接表
	int vexnum,arcnum;//图的顶点数和弧度
}ALGraph;
```

 

**邻接表的特点:**

1. 在无向图中所需的存储空间为O(|v|+2|E|),在有向图中所需的存储空间为O(|V|+|E|),前者之所以是两倍,是因为无向图每条边在邻接表出现了2次
2. 对于稀疏图,邻接表将会极大的节省空间
3. 在邻接表中给定一个结点很容易找出它的所有邻边,花费的时间为O(n),但要确定两个顶点间是否存在边则需要在对应的边表中查找另一个结点
4. 在邻接表中求一个给定结点的出度只需要计算邻接表的个数,但求入度需要遍历整个邻接表,因此可以采用逆邻接表来迅速求解入度
5. 图的邻接表并不唯一,因为各边连接次序可能不一样



#### 1.2.3十字链表

**十字链表是有向图的一种链式存储结构**

在十字链表中,每条弧有一个结点,对应每个顶点也有一个结点

十字链表的结点结构:

<img src="E:\数据结构\image\十字链表的结点结构.png" style="zoom:38%;" />

有向图的十字链表表示:

<img src="E:\数据结构\image\有向图的十字链表表示.png" style="zoom:38%;" />



#### 1.2.4邻接多重表

**邻接多重表是无向图中的一种链式存储结构**

邻接表中,很容易得到顶点和边的各种信息,但求两顶点之间是否存在边进行的一系列的操作时,需要遍历两个顶点的边表,效率较低

邻接多重表便解决了这个问题

<img src="E:\数据结构\image\邻接多重表.png" style="zoom:38%;" />





## 2.图的遍历

### 2.1BFS(广度优先搜索)

思想:以v为起始点,由近到远依次访问和v有路径相同的顶点(类比于二叉树的层序遍历)

伪代码如下:

```cpp
bool visited[MAX_VERTEX_NUM];//访问标记数组

void BFSTraverse(Grapg G){
	for(int i=0;i<G.vexnum;i++){
		visited[i]=false;//访问数组初始化
	}
	InitQueue(Q);//初始化辅助队列
	for(int i=0;i<G.vexnum;i++){//从0号顶点开始遍历
		if(!visited[i]) BFS(G,i);//对每个连通分量调用一次BFS
	}
}

void BFS(Graph G,int v){//从顶点v开始出发,广度优先遍历G
	visit(v);//访问初始顶点v
	visited[v]=TRUE;//对v进行已访问标记
	Enqueue(Q,v);//v入队列
	while(!isEmpty(Q)){
		DeQueue(Q,v);
		for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))//检测所有邻接点
			if(!visited[w]){//如果w是未访问结点
				visit(W);//访问结点w
				visited[w]=TRUE;//做已访问标记 
				EnQueue(Q,w);//w入队列
			}
	}
}
```



例如:一个无向图G:

<img src="E:\数据结构\image\BFS无向图G.png" style="zoom:38%;" />

它的BFS遍历次序是:abcdefgh



BFS的**空间复杂度为O(|v|)**,其中v是辅助队列的大小,最坏的情况是n个顶点均要入队

按**邻接表的存储方式**,每个结点均需要搜索一次,时间复杂度为O(|v|),在搜索任意顶点的邻接表时,每一条边至少访问一次,时间复杂度为O(|E|),**算法总的时间复杂度为O(|v|+|E|)**

按**邻接矩阵存储方式**,找查每个结点的邻接点所需时间为O(|v|),**算法总的时间复杂度为**
$$
O(|v^2|)
$$


**此外BFS可以求解非带权图的单源最短路径问题**



广度搜索过程中,我们可以得到一棵遍历树,称为**广度优先生成树**

注:由于同一图中,**邻接矩阵**是唯一的,故其**广度优先生成树**也**是唯一的**,但由于**邻接表**不是唯一的,其**广度优先生成树**也**不是唯一的**





### 2.2DFS(深度优先搜索)

思想:尽可能深的搜索某一个图(类比于二叉树的先序遍历)



```cpp
bool visited[MAX_VERTEX_NUM];//访问标记数组
void DFSTraverse(Graph G){
	for(int v=0;v<G.vex;v++) visited[v]=false;//初始化已访问数组
	for(int v=0;v<G.vexnum;v++){//从0这个顶点开始遍历
		if(!visited[v]) DFS(G,v);
	}
}

void DFS(Graph G,int v){
	visited(v);
	visited[v]=TRUE;
	for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))//检测所有邻接点
			if(!visited[w]){//如果w是未访问结点
				DFS(G,w);
			}
}
```



例如:一个无向图G:

<img src="E:\数据结构\image\BFS无向图G.png" style="zoom:38%;" />

它的DFS遍历次序是abdehcfg



DFS是一个递归算法,需要借助一个栈,空间复杂度为O(|V|)

按**邻接表的存储方式**,每个结点均需要搜索一次,时间复杂度为O(|v|),在搜索任意顶点的邻接表时,每一条边至少访问一次,时间复杂度为O(|E|),**算法总的时间复杂度为O(|v|+|E|)**

按**邻接矩阵存储方式**,找查每个结点的邻接点所需时间为O(|v|),**算法总的时间复杂度为**



深度优先搜索过程中,我们可以得到一棵遍历树,称为**深度优先生成树**



注:**图的遍历算法可以判断图的连通性**(看遍历完是否访问到所有顶点)





## 3.图的应用

### 3.1最小生成树

**最小生成树:**一个带权连通无向图中,边的权值之和最小的生成树



**最小生成树的性质:**

1. **最小生成树不是唯一的**,当图中各边权值都互不相等时,最小生成树唯一,当图的边数比顶点数少1时,最小生成树就是它本身;
2. **最小生成树的边的权值之和是唯一的且最小**
3. **最小生成树的边数为顶点数减1**



**构造最小生成树的算法**:

1. **prim(普里姆)算法**

   总结:选取某一个顶点,每次寻找与该顶点相关的权值最小边对应的顶点,然后再寻找这两个顶点相关的权值最小的边对应的顶点,不断重复进行,直至顶点全部被联系起来

   时间复杂度为
   $$
   O(|v^2|)
   $$
   其中是顶点的数目,因此时间复杂只与顶点的个数相关,不依赖于边,更适合边稠密图

   <img src="E:\数据结构\image\prim构造最小生成树.png" style="zoom:38%;" />

2. **Kruskal(克鲁斯卡尔)算法**

   总结:每次找到未选取过的权值最小边以及对应的两个顶点,并且要求两个顶点间只有一条路径,直至所有顶点被联系起来

   时间复杂度为:
   $$
   O(|E|log_2|E|)
   $$
   时间复杂度与边相关,因此该算法适合于边稀疏而顶点多的图

   <img src="E:\数据结构\image\Kruskal算法构造最小生成树.png" style="zoom:38%;" />



### 3.2最短路径

1. **Dijkstra算法**

   与prim算法有些类似,基于贪心策略

   总结:先选取某个顶点,然后找到相邻的第二个结点,选取这一轮的最短路径,然后再选取与第二个结点相邻的第三个结点,选取这一轮的最短路径,依次类推

   <img src="E:\数据结构\image\Dijkstra算法实现过程.png" style="zoom:38%;" />

   时间复杂度为
   $$
   O(|v^2|)
   $$

2. **Floyd算法**

   基于动态规划策略

   总结:依次选取不同的结点作为中间站,用二维数组将每次的最短路径记录下来

   <img src="E:\数据结构\image\Floyd算法图G.png" alt="3" style="zoom:38%;" />

   <img src="E:\数据结构\image\Floyd算法执行过程图.png" style="zoom:38%;" />

   时间复杂度为
   $$
   O(|v^3|)
   $$

### 3.3有向无环图描述表达式

**有向无环图(DAG图)**:不存在环的有向图

例如:<img src="E:\数据结构\image\有向无环图表达式.png" style="zoom:38%;" />

<img src="E:\数据结构\image\有向无环图描述表达式.png" style="zoom:38%;" />

左图是二叉树,右图是有向无环图,相比较下来,**更节省空间**



### 3.4拓扑排序

**AOV网**:用DAG图表示一个工程,其顶点表示活动的网格

**拓扑排序**:在图论中,由一个有向无环图的顶点组成的序列,当前仅当满足以下条件时的图:

1. 每个顶点只出现一次
2. 若顶点A在序列中排在顶点B前面,则在该图中不存在从顶点B到顶点A的路径



拓扑排序的方法:

1. 从AOV网中选择一个没有前驱的顶点并输出
2. 从网中删除该顶点和所有以它为起点的有向边
3. 重复步骤1和2知道当前AOV网为空或当前网中不存在无前驱的顶点为止



拓扑排序的过程:

<img src="E:\数据结构\image\拓扑排序的过程.png" style="zoom:38%;" />





​																																											<by:缥缃



# 第七章 查找

<img src="E:\数据结构\image\查找.png" style="zoom:38%;" />

## 1.查找的基本概念

**查找**:在数据集合中寻找满足某种条件的数据元素的过程

**查找表**:用于查找数据的集合

**静态查找表**:如果一个查找表的操作不会修改该查找表(例如查询,检索,但插入和删除就不满足)的查找表

**关键字**:数据元素中唯一表示该元素的某个数据项的值

**平均查找长度:**所有查找过程中进行关键字比较次数的平均值



## 2.顺序查找和折半查找

### 2.1顺序查找

**顺序查找(线性查找)**:顺序扫描每个元素



**一般顺序表的顺序查找**:

```cpp
typedef struct{
	ElemType *elem;
	int TableLen;
}SSTable;

int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;
    for(int i=ST.TableLen;ST.elem[i]!=key;--i)//从后往前找
    return i;//返回索引位置
}
```



顺序查找的平均长度为
$$
ASL_{成功}=\sum^n_{i=1}p_i(n-i-1)=(n-1)/2
$$
查找不成功为n+1



顺序查找的优点:对数据元素的存储没有要求,顺序存储和链式存储皆可.对表中记录的有序性没有要求

顺序查找的缺点:当n较大时,平局一年查找长度较大,效率低



**有序表的顺序查找:**

若在查找之前已知表中关键字有序,则查找失败可以不用比较到表的另一端就能返回查找失败的信息,从而降低顺序查找事变的平均查找长度

例如已知表L关键字从小到大排序,查找关键字key,当查找到第i个元素时,发现第i个元素对应的关键字小于key,但第i+1个关键字大于key,则返回表中不存在关键字key的元素



### 2.2折半查找(二分查找)

**适用条件:**有序的顺序表

**思想**:先将给定的值key于表中中间位置的元素比较,若相等,则查找成功返回该元素的位置,若不等所查找的元素只能在中间元素外的前半部分或后半部分,然后缩小范围继续同样的查找



```cpp
int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.TableTen-1,mid;
    while(low<=high){
        mid=(low+high)/2;
        if(L.elem[mid]==key) return mid;
        else if(L.elem[mid]>key) high=mid-1
        else low=mid+1;
    }
	return -1;
}
```



平均查找长度:
$$
ASL=log_2(n+1)-1
$$




### 2.3分块查找(索引顺序查找)

**思想**:将查找表分成若干块,块内元素可以无序,但块间元素是有序的,即第一个块中的最大关键字小于第二个块中所有记录的关键字,一次类推,再建立索引表,索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址,索引表按关键字有序排列

分块查找的过程:

1. 再索引表中确定待查记录所在的块,可以顺序查找或折半查找索引表
2. 在块内顺序查找

<img src="E:\数据结构\image\分块查找.png" style="zoom:38%;" />





## 3.树形查找

### 3.1二叉排序树(BST)

构造二叉排序树的目的并不是为了排序,而是为了提高查找,插入和删除关键字的效率



**二叉排序树**:具有以下特性的二叉树:

1. 若左子树非空,则左子树上所有结点的值均小于根结点的值
2. 若右子树非空,则右子树上所有结点的值均大于根结点的值
3. 左右子树也分别是一棵二叉排序树

总结:
$$
左子树<根结点<右子树
$$
**二叉排序树的查找**:

先从根结点开始,沿分支逐层向下比较

```cpp
BSTNode *BST_Search(BiTree T,ElemType key){
    while(T!=NULL&&key!=T->data){
        if(key<T->data) T=T->lchild;
        else T=T->rchild;
    }
    return T;
}
```



**二叉排序树的插入:**

若原二叉排序树为空,则直接插入,否则若关键字key小于根结点值,则插入到左子树,若key大于根结点的值则插入到右子树.插入的结点一定是一个新添加的叶结点,且是查找失败时查找路径上访问的最后一个结点的左孩子或右孩子

```cpp
int BST_Insert(BiTree &T,KeyType k){
	if(T==NULL){
		T=(BiTree)malloc(sizeof(BSTNode));
        T->data=k;
        T->lchild=T->child=NULL;
        return 1;
	}else if(k==T->data) return 0;
    else if(k<T->data) return BST_Insert(T->lchild,k);
    else return BST_Insert(T->rchild,k);
}
```



**二叉排序树的构造:**

```cpp
void Creat_BST(BiTree &T,KeyType str[],int n){
	T=NULL;
    int i=0;
    while(i<n){
        BST_Insert(T,str[i]);
        i++
    }
}
```



**二叉排序树的删除:**

在二叉排序树中删除一个结点时,不能把以该结点为根的子树上的结点都删除,必须先把被删除结点从存储二叉排序树的链表上摘下,将因删除结点而断开的二叉链表重新连接起来,同时确保二叉排序树的性质不会丢失

删除操作的三种情况:

1. 若删除结点z是叶结点则直接删除
2. 若结点z只有一颗左子树或右子树,则让z的子树称为z父结点的子树,替代z的位置
3. 若z有两颗子树,则令z的直接后继(或直接前驱)替代z,然后从二叉排序树中删除这个直接后继,这样就转换成了第一或第二种情况



### 3.2平衡二叉树(AVL)

**平衡二叉树:**在二叉树种任意结点的左右子树高度差不超过1

**目的:**避免树的高度增长过快,降低二叉排序树的性能

**平衡因子:**定义结点左子树与右子树的高度差

平衡二叉树的平衡因子只可能是-1,0,1



**平衡二叉树的插入:**

插入结点后,调整各结点的位置关系,使之重新达到平衡



插入的四种调整情况:

1. LL平衡旋转(右单旋转):在结点A的左孩子(L)的左子树(L)上插入新结点,让以A为根的整棵子树右上旋转

   <img src="E:\数据结构\image\LL平衡旋转.png" style="zoom:38%;" />

2. RR平衡旋转(左单旋转):在结点A的右孩子(R)的右子树(R)上插入新结点,让以A为根的整棵子树左上旋转

   <img src="E:\数据结构\image\RR平衡旋转.png" style="zoom:38%;" />

3. LR平衡旋转(先左后右双旋转):在结点A的左孩子(L)的右子树(R)上插入新结点,先左旋再右旋

   <img src="E:\数据结构\image\LR平衡旋转.png" style="zoom:38%;" />

4. RL平衡旋转(先右后左双旋转):在结点A的右孩子(R)的左子树(L)上插入新结点,先右旋再左旋

   <img src="E:\数据结构\image\RL平衡旋转.png" style="zoom:38%;" />

   

   

**平衡二叉树的删除**与上述规则类似

**平衡二叉树的查找**平均长度为O(log2n)





## 4.B树和B+树

### 4.1B树及其基本操作

**m阶B树:**满足以下特性的m叉树:

1. 树中每个结点至多有m棵子树,即至多含有m-1个关键字

2. 若根结点不是叶结点,则至少有两棵子树

3. 若除根结点外所有非叶结点至少含有
   $$
   \lceil m/2 \rceil
   $$
   棵子树,即至少含有
   $$
   \lceil m/2 \rceil-1
   $$
   个关键字

​                   

<img src="E:\数据结构\image\B树的实例.png" style="zoom:38%;" />

**B树的高度(磁盘存取次数)**

<img src="E:\数据结构\image\B树的高度.png" style="zoom:38%;" />

**B树的查找**

<img src="E:\数据结构\image\B树的查找.png" style="zoom:38%;" />

**B树的插入**

<img src="E:\数据结构\image\B树的插入.png" style="zoom:38%;" />

**B树的删除**

<img src="E:\数据结构\image\B树的删除.png" style="zoom:38%;" />

### 4.2B+树的基本概念

B+树是应数据库所需的一种B树的变形树



## 5.散列表(哈希表)

### 5.1散列表的基本概念

**散列函数:**一个把查找表中的关键字映射成该关键字对应的地址的函数,记为Hash(key)=Addr

**冲突:**散列函数可能会把两个或两个以上的不同关键字映射到同一地址

**同义词:**发生碰撞的不同关键字

**散列表:**根据关键字而直接进行访问的数据结构,也就是说散列表建立了关键字和存储地址之间的一种直接映射关系

理想情况下,对散列表进行查找的时间复杂度为O(1)



### 5.2散列函数的构造方法

构造时的注意事项:

1. 散列函数的定义域必须包含全部需要存储的关键字,而值域范围则依赖于散列表的大小或地址范围
2. 散列函数计算出来的地址应该等概率,均匀地分布在整个地址空间中,从而减少冲突的发生
3. 散列函数应该尽量简单,能够在较短时间内计算出任意关键字对应的散列地址



1.**直接定址法**

直接取关键字的某个线性函数值为散列地址,散列函数为
$$
H(key)=key或H(key)=a*key+b
$$
2.**除留余数法**

最常见,最简单的方法

假定散列表长为m,取一个不大于m但最接近或等于m的质数p,利用以下公式把关键字转换成散列地址,散列函数为
$$
H(key)=key \% p
$$
3.**数字分析法**

设关键字是r进制数,而r个数码在各位出现的频率不一定相同,可能会在某些位上分布均匀一些,每种数码出现的机会均等,而在某些位上分布不均匀,只有某几种数码经常出现,此时应选取数码分布较为均匀的若干位作为散列地址,此方法适合于已知关键字集合,若更换了关键字需要重新构造新的散列函数

4.**平方取中法**

取关键字的平方中间几位作为散列地址



**处理冲突的方法:**

1. **开放地址法**

   **开放地址法:**可存放新表项的空闲地址既向它的同义词表项开放,又向非同义词表项开放,其数学递推公式为
   $$
   H_i=(H(key)+d_i)\%m
   $$
   H(key)为散列函数,m为表长,d为增量序列

   取定增量序列的方法:

   1. 线性探测法
   2. 平方探测法
   3. 双散列法
   4. 伪随机序列法

2. **拉链法**

   将所有同义词存储在一个线性链表中,这个线性链表由其其散列地址唯一标识



### 5.3散列查找的性能分析

散列表的查找效率取决于三个因素:散列函数,处理冲突的方法和装填因子

装填因子
$$
\alpha=表中记录数n/散列表的长度m
$$
散列表的平均查找长度依赖于装填因子,不直接依赖于n或m



​																																																						<by:缥缃



# 第八章 排序

<img src="E:\数据结构\image\排序.png" style="zoom:38%;" />

## 1.排序的基本概念

**排序:**重新排列表中的元素,使表中的元素满足按关键字有序的过程

**算法的稳定性:**

1. **稳定的**:假设某个排序表中,有两个相同的关键字A和B(A在B的前面),使用某一排序算法后,A仍然在B的前面
2. **不稳定的:**假设某个排序表中,有两个相同的关键字A和B(A在B的前面),使用某一排序算法后,B在A的前面

例如:在一组数据 1 2 5 3 1 4中在经过某个排序算法排序后,前面的1的仍然是在后面的1前面则说明这个算法是稳定的,反之



排序算法的分类(看数据元素是否完全在内存中):

1. 内部排序:排序期间元素全部存放在内存中的排序 
2. 外部排序:排序期间元素无法全部同时存放在内存中,必须在排序的过程中要求不断地在内外存之间移动的排序

注:内部排序算法一般有两个操作:比较和移动,大部分内部排序算法只适用于顺序存储的线性表



## 2.插入排序

思想:每次将一个待排序的记录按关键字大小插入前面已排好序的子序列

### 2.1直接插入排序

将一个待排序的记录按关键字大小插入前面已排好序的子序列

<img src="E:\数据结构\image\直接插入排序示例.png" style="zoom:38%;" />

```cpp
void InsertSort(ElemType A[],int n){
	int i,j;
    for(i=2;i<=n;i++){//依次查找关键字,从2下标开始
        if(A[i]<A[i-1]){//若关键字小于前驱时
            A[0]=A[i];//记录下关键字
            for(j=i-1;A[0]<A[j];j--){//将关键字插入的位置到原关键字的位置向后移动一个
                A[j+1]=A[j];//移动
            }
            A[j+1]=A[0];//将空出的位置的关键字补上
        }
    }
}
```

空间复杂度O(1)

时间复杂度
$$
O(n^2)
$$
最好的情况,表中元素已经有序,不需要移动元素,只需要比较n次,O(n)

最坏的情况,表中元素正好逆序

适用性:顺序存储和链式存储的线性表



### 2.2折半插入排序

将一个待排序的记录按关键字大小插入前面已排好序的子序列,但查找插入的位置利用折半查找(因为前面的子序列有序所以可以使用折半查找)

```cpp
void InsertSort(ElemType A[],int n){
	int i,j,low,high,mid;
    for(i=2;i<=n;i++){
        A[0]=A[i];
        low=1;
        high=i-1;
        while(low<=high){
            mid=(low+high)/2;
            if(A[mid]>A[0]) high=mid-1;
            else low=mid+1;
        }
        for(j=i-1;j>=high+1;j--){
            A[j+1]=A[j];
        }
        A[j+1]=A[0];
    }
}
```

时间复杂度仍然为
$$
O(n^2)
$$
但减少了比较次数(折半查找的时间复杂度),对于数据量不是很大的排序表,折半插入排序会表现出更好的性能

### 2.3希尔排序

又上述可知插入排序当表基本有序时,时间效率会有显著提高,因此我们可以基于这样的思想完善插入排序得到希尔排序

**希尔排序的思想:**将排列表分割成若干个子表,然后对各个子表进行直接插入排序

```cpp
void ShellSort(ElemType A[],int n){
	int dk,i,j;
    for(dk=n/2;dk>=1;dk=dk/2)//增量变化(无同一规定)
        for(i=dk+1;i<=dk;i++)
            if(A[i]<A[i-dk]){
                A[0]=A[i];
                for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
                    A[j+dk]=A[j];
                A[j+dk]=A[0];
            }
}
```

空间效率为:O(1)

时间效率:平均下来
$$
O(n^{1.3})
$$
最差
$$
O(n^2)
$$
稳定性:不稳定

适用性:仅适用于线性表为顺序存储的情况



## 3.交换排序

**交换:**将两个元素关键字的比较结果来对换这两个记录在序列中的位置

### 3.1冒泡排序

思想:从后往前(或从前往后)两两比较相邻元素的值,若为逆序则交换它们

<img src="E:\数据结构\image\冒泡排序.png" style="zoom:38%;" />

```cpp
void BubbleSort(ElemType A[],int n){
	for(int i=0;i<n-1;i++){
        bool flag=false;//表示本次冒泡是否发生交换的标志
        for(int j=n-1;j>i;j--){//一趟冒泡排序
            if(A[j-1]>A[j]){//如果相邻元素为逆序
                swap(A[j-1],A[j]);//交换
                flag=true;
            }
        }
        if(flag==false) return;//若没有发生交换则说明已经有序
    }	
}
```

空间效率:O(1)

时间效率:
$$
O(n^2)
$$
最好的情况是O(n),表中已经有序只需要比较,不需要交换



### 3.2快速排序

基本思想:分治法

在排序表中任取一个元素pivot作为枢轴,将排序表分为两部分,使前面的一部分全部小于pivot,后面的一部分全部大于pivot,这样不断划分

例如,取第一个元素49作为pivot

<img src="E:\数据结构\image\快速排序.png" style="zoom:38%;" />

```cpp
void QuickSort(ElemType A[],int low,int high){
	if(low<high){
        int pivotpos=Partition(A,low,high);//划分
        QuickSort(A,low,pivotpos-1);//依次对两个子表进行划分
        QuickSort(A,pivotpos+1,high);
    }
}

int Partition(ElemType A[],int low,int high){
    ElemType pivot=A[low];//取第一个元素作为枢轴
    while(low<high){//跳出循环条件
        while(low<high&&A[high]>=pivot) --high;//找到比枢轴小的元素,并将指针指向它
        A[low]=A[high];//将枢轴小的元素移动到左端
        while(low<high&&A[low]<=pivot) ++low;//找到比枢轴大的元素,并将指针指向它
        A[high]=A[low];//将枢轴大的元素移动到右端
    }
    A[low]=pivot;//枢轴元素存放到最终的位置
    return low;//返回最终位置
}
```

空间效率:需要借助一个递归工作栈,其**容量与递归调用的最大深度一致**

​	最好的情况下为
$$
O(log_2n)
$$
​	最坏的情况下要调用n-1次

​	平均情况下是
$$
O(log_2n)
$$
时间效率:**快速排序是所有内部排序算法中平均性能最优的排序算法**,其时间复杂度为
$$
O(nlog_2n)
$$
​	**最坏的情况下,初始排序表基本有序或逆序**时,时间复杂度为
$$
O(n^2)
$$
稳定性:不稳定



## 4.选择排序

选择:在每一趟待排序的元素中选取关键字最小的元素,作为有序子序列的第i个元素,直到结束

### 4.1简单选择排序

```cpp
void SelectSort(ElemType A[],int n){
	for(int i=0;i<n-1;i++){//遍历
        int min=i;//记录最小元素位置
        for(int j=i+1;j<n;j++){//在i到n-1中选择最小的元素
            if(A[j]<A[min]) min=j;//更新最小的元素
        }
        if(min!=i) swap(A[i],A[min]);//两个元素交换
    }
}
```

空间效率:O(1)

时间复杂度为
$$
O(n^2)
$$
最好的情况,已经有序,只需要比较,不需要交换,时间复杂度仍然不变

稳定性:不稳定



### 4.2堆排序

**堆:**满足以下条件的n个关键字序列L[1...n]:

1. L(i)>=L(2i)且L(i)>=L(2i+1)或
2. L(i)<=L(2i)且L(i)<=L(2i+1)

满足条件1的堆叫**大根堆**,满足条件2的堆叫**小根堆**

大根堆的示意图:

<img src="E:\数据结构\image\大根堆的示意图.png" style="zoom:38%;" />

堆排序的思路:输出堆顶元素(最大或最小),将栈底元素送入堆顶,调整堆,使之满足大根堆或小根堆,依次重复



**构造初始堆:**

<img src="E:\数据结构\image\构造初始堆.png" style="zoom:38%;" />

**自下往上调整大根堆:**

<img src="E:\数据结构\image\自下往上调整大根堆.png" style="zoom:38%;" />

**输出堆顶元素后调整大根堆**:

将上面的大根堆的堆顶元素输出,然后将堆中的最后一个元素09与堆顶元素交换,选取左右孩子较大者交换,然后同样的调整

<img src="E:\数据结构\image\输出堆顶元素后调整新堆.png" style="zoom:38%;" />

建立大根堆的算法:

```cpp
void BuildMaxHeap(ElemType A[],int len){
	for(int i=len/2;i?0;i--) HeadAdjust(A,i,len);
}

void HeadAdjust(ElemType A[],int k,int len){
    A[0]=A[k];//A[0]暂存子树根结点
    for(int i=2*k;i<=len;i*=2){
        if(i<len&&A[i]<A[i+1]) i++;//取key较大的子结点下标
        if(A[0]>=A[i]) break;//筛选结束
        else{
            A[k]=A[i];//将A[i]调整到双亲结点上
            k=i;//修改k值,以便继续向下筛选
        }
    }
    A[k]=A[0];//被筛选结点的值放入最终位置
}

void HeapSort(ElemType A[],int len){
    BuildMaxHeap(A,len);//构建堆
    for(int i=len;i>1;i--){//n-1趟交换和建堆的过程
        Swap(A[i],A[1]);//输出堆顶元素
        HeadAdjust(A,1,i-1);//调整
    }
}
```

堆同时也能进行插入操作,将新结点放在堆的末端,然后一样的进行调整操作



空间效率:O(1)

时间效率:
$$
O(nlog_2n)
$$
稳定性:不稳定



## 5.归并排序和基数排序

### 5.1归并排序

思想:将两个或两个以上的有序表合并成一个新的有序表,当两两归并时又称二路归并排序

<img src="E:\数据结构\image\二路归并排序示例.png" style="zoom:38%;" />

```cpp
ElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));//辅助数组B
void Merge(ElemType A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++) B[k]=A[k];//将A中元素全部复制到B中
    for(i=low;j=mid+1,k=i;i<=mid&&j<=high;k++){
        if(B[i]<=B[j]) A[k]=B[i++];//将较小值复制到A中去
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];//若第一个表未检测完,复制
    while(j<=high) A[k++]=B[j++];//若第二个表未检测完,复制
}

void MergeSort(ElemType A[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;
        MergeSort(A,low,mid);//左侧子序列递归排序
        MergeSort(A,mid+1,high);//右侧子序列递归排序
        Merge(A,low,mid,high);//归并
    }
}
```

空间效率:O(n)

时间效率:
$$
O(nlog_2n)
$$
稳定性:稳定





### 5.2基数排序

不基于移动和比较

思想:基于关键字各位的大小

例如:一个三位的数字,先比较个位数进行排序,再比较十位数排序,再比较百位数排序,每个  位数相等的记录分配到同一个队列,然后收集

<img src="E:\数据结构\image\基数排序的示例.png" style="zoom:38%;" />

<img src="E:\数据结构\image\基数排序的具体步骤.png" style="zoom:38%;" />

空间效率:一趟排序需要辅助空间为r(r个队列,r个队头指针,r个队尾指针),空间复杂度为O(r)

时间效率:需要进行d趟分配和收集,每次分配需要O(n),一趟收集需要O(r),时间复杂度为O(d(n+r))

稳定性:稳定









​																																																						<by:缥缃
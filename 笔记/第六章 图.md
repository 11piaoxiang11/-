# 第六章 图

<img src="E:\数据结构\image\图.png" style="zoom:38%;" />

## 1.图的基本概念

### 1.1图的定义

图G有顶点集V和边集E组成,记为G=(V,E),其中V(G)表示图中顶点的有限非空集;E(G)表示图G中顶点之间的关系(边)集合



注:图不能为空图,即图的顶点集V一定非空,E可以为空



**有向图:**E是有向边(弧)的有限集合时的图

弧是顶点的有序对,记为<v,w>,其中v为弧尾,w为弧头

总结:在图中看到边全部有箭头指明方向就是有向图



**无向图:**E是无向边的有限集合时的图

总结:在图中看到边没有箭头就是无向图



**简单图:**在一个图中满足:

1. 不存在重复边
2. 不存在自身到自身的边

的图,与之相反的是**多重图**,一般情况下,图都是简单图

总结,在图中没有出现可以省略不画的边叫简单图



**完全图(简单完全图):**有n(n-1)/2条边的**无向图**
$$
C^2_n=n(n-1)/2
$$
总结,在无向图中 ,让每两个顶点都有一条连接的边的图,即满足上述公式

**注:一定是在无向图中**



**子图:**顶点集是另一个图中顶点集的子集,边集是另一个图中边集的子集的图

总结:类比与子集



**连通:**两顶点间有路径存在(可以从一个顶点到达另一个顶点,不一定要直接相连,可间接)

**连通图:**图中任意两个顶点都是连通的图(图中随便挑两个顶点都可以从一个顶点到达另一个顶点)

**非连通图:**不满足连通图的图

**连通分量:**无向图中的极大连通子图(即该**连通子图**需要**包含图中所有的边**)

**连通图的生成树:**包含图中所有顶点的极小连通子图(即该**连通子图**需要包含**图中边数最小的边**)

注:

1. 假设一个图有n个顶点,如果边数小于n-1,那么此图一定是非连通图(因为,要使任意两个顶点连通且边数最小需要n-1条边,类比于顶点与边围成一个圆,再删去一条边)
2. **一定是在无向图中**



**强连通图:**在有向图中,任意两个顶点v和w,两者之间可互相到达(有方向),有路径的图

**强连通分量:**有向图中的极大强连通子图

注:**一定是在有向图中**



**度**:依附于顶点v的边的条数(即连在结点v上的边有几条)

根据定义,我们可以知道在无向图中,一条边影响着两个顶点,会出现两个度,因此在一个有e条边无向图中,图的度数之和为2e,即**无向图中全部顶点度数的和等于边数的两倍**

在**有向图中,图的度分为入度和出度**

**入度**:以顶点为终点的有向边的数目(箭头指向这个顶点的边)

**出度:**以顶点为起点的有向边的数目(箭头离开这个顶点的边)

度=入度+出度



**权**:每条边标上具有某种含义的数值

**带权图(网):** 边上带有权值的图



**稠密图:**边数很多的图

**稀疏图:**边数很少的图



**路径:**两顶点之间有可达的边

**路径长度:**路径上边的数目

**简单路径:**顶点不重复出现的路径

**距离:**两顶点之间的最短路径

**有向树:**一个顶点入度为0,其余顶点入度均为1的有向图



### 1.2图的存储及基本操作

图的存储必须要完整,准确地反应顶点集和边集的信息

#### 1.2.1邻接矩阵法

**邻接矩阵存储:**用一个一维数组存储图中顶点的信息,用一个二维数组存储图中边的信息,存储顶点间邻接关系的二维数组称为**邻接矩阵**

<img src="E:\数据结构\image\邻接矩阵的表示.png" style="zoom:38%;" />

```cpp
#define MaxVertexNum 100
typedef char VertexType;//顶点的数据类型
typedef int EdgeType;//权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];//顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵
	int vexnum,arcnum;//顶点数和弧数
}MGraph
```

<img src="E:\数据结构\image\各种图的邻接矩阵.png" style="zoom:38%;" />

**邻接矩阵的特点:**

1. 无向图中,邻接矩阵一定是一个对称矩阵,因此在实际中只需要存储三角矩阵元素
2. 无向图中,邻接矩阵的第i行的非零元素之和恰好是i的度
3. 有向图中,邻接矩阵的第i行的非零元素之和恰好是i的出度,第i列的非零元素之和恰好是i的入度
4. 邻接矩阵存储图,能够容易地确定两顶点间是否有边相连,但要确定有多少边需要对每个元素进行检测
5. 稠密图适合邻接矩阵的存储表示



#### 1.2.2邻接表法

当图为稀疏图时,使用邻接矩阵会浪费大量空间,而邻接表法结合顺序存储和链式存储方法,大大减小了浪费

邻接表示法的结点结构:

<img src="E:\数据结构\image\邻接表示法的结点结构.png" style="zoom:38%;" />

无向图的邻接表示法:

<img src="E:\数据结构\image\无向图的邻接表示法.png" style="zoom:38%;" />

有向图的邻接表示法:

<img src="E:\数据结构\image\有向图的邻接表示法.png" style="zoom:38%;" />



```cpp
#define MaxVertexNum 100//图中顶点数目的最大值
typedef struct ArcNode{//边表结点
	int adjvex;//该弧所指向的顶点的位置
	struct ArcNode* next;//指向下一条弧的指针
}ArcNode;

typedef struct VNode{//顶点表结点
	VertexType data;//顶点信息
	ArcNode *first;//指向第一条依附该顶点的弧的指针
}VNode,AdjList[MaxVertexNum];

typedef struct {
	AdList vertices;//邻接表
	int vexnum,arcnum;//图的顶点数和弧度
}ALGraph;
```

 

**邻接表的特点:**

1. 在无向图中所需的存储空间为O(|v|+2|E|),在有向图中所需的存储空间为O(|V|+|E|),前者之所以是两倍,是因为无向图每条边在邻接表出现了2次
2. 对于稀疏图,邻接表将会极大的节省空间
3. 在邻接表中给定一个结点很容易找出它的所有邻边,花费的时间为O(n),但要确定两个顶点间是否存在边则需要在对应的边表中查找另一个结点
4. 在邻接表中求一个给定结点的出度只需要计算邻接表的个数,但求入度需要遍历整个邻接表,因此可以采用逆邻接表来迅速求解入度
5. 图的邻接表并不唯一,因为各边连接次序可能不一样



#### 1.2.3十字链表

**十字链表是有向图的一种链式存储结构**

在十字链表中,每条弧有一个结点,对应每个顶点也有一个结点

十字链表的结点结构:

<img src="E:\数据结构\image\十字链表的结点结构.png" style="zoom:38%;" />

有向图的十字链表表示:

<img src="E:\数据结构\image\有向图的十字链表表示.png" style="zoom:38%;" />



#### 1.2.4邻接多重表

**邻接多重表是无向图中的一种链式存储结构**

邻接表中,很容易得到顶点和边的各种信息,但求两顶点之间是否存在边进行的一系列的操作时,需要遍历两个顶点的边表,效率较低

邻接多重表便解决了这个问题

<img src="E:\数据结构\image\邻接多重表.png" style="zoom:38%;" />





## 2.图的遍历

### 2.1BFS(广度优先搜索)

思想:以v为起始点,由近到远依次访问和v有路径相同的顶点(类比于二叉树的层序遍历)

伪代码如下:

```cpp
bool visited[MAX_VERTEX_NUM];//访问标记数组

void BFSTraverse(Grapg G){
	for(int i=0;i<G.vexnum;i++){
		visited[i]=false;//访问数组初始化
	}
	InitQueue(Q);//初始化辅助队列
	for(int i=0;i<G.vexnum;i++){//从0号顶点开始遍历
		if(!visited[i]) BFS(G,i);//对每个连通分量调用一次BFS
	}
}

void BFS(Graph G,int v){//从顶点v开始出发,广度优先遍历G
	visit(v);//访问初始顶点v
	visited[v]=TRUE;//对v进行已访问标记
	Enqueue(Q,v);//v入队列
	while(!isEmpty(Q)){
		DeQueue(Q,v);
		for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))//检测所有邻接点
			if(!visited[w]){//如果w是未访问结点
				visit(W);//访问结点w
				visited[w]=TRUE;//做已访问标记 
				EnQueue(Q,w);//w入队列
			}
	}
}
```



例如:一个无向图G:

<img src="E:\数据结构\image\BFS无向图G.png" style="zoom:38%;" />

它的BFS遍历次序是:abcdefgh



BFS的**空间复杂度为O(|v|)**,其中v是辅助队列的大小,最坏的情况是n个顶点均要入队

按**邻接表的存储方式**,每个结点均需要搜索一次,时间复杂度为O(|v|),在搜索任意顶点的邻接表时,每一条边至少访问一次,时间复杂度为O(|E|),**算法总的时间复杂度为O(|v|+|E|)**

按**邻接矩阵存储方式**,找查每个结点的邻接点所需时间为O(|v|),**算法总的时间复杂度为**
$$
O(|v^2|)
$$


**此外BFS可以求解非带权图的单源最短路径问题**



广度搜索过程中,我们可以得到一棵遍历树,称为**广度优先生成树**

注:由于同一图中,**邻接矩阵**是唯一的,故其**广度优先生成树**也**是唯一的**,但由于**邻接表**不是唯一的,其**广度优先生成树**也**不是唯一的**





### 2.2DFS(深度优先搜索)

思想:尽可能深的搜索某一个图(类比于二叉树的先序遍历)



```cpp
bool visited[MAX_VERTEX_NUM];//访问标记数组
void DFSTraverse(Graph G){
	for(int v=0;v<G.vex;v++) visited[v]=false;//初始化已访问数组
	for(int v=0;v<G.vexnum;v++){//从0这个顶点开始遍历
		if(!visited[v]) DFS(G,v);
	}
}

void DFS(Graph G,int v){
	visited(v);
	visited[v]=TRUE;
	for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))//检测所有邻接点
			if(!visited[w]){//如果w是未访问结点
				DFS(G,w);
			}
}
```



例如:一个无向图G:

<img src="E:\数据结构\image\BFS无向图G.png" style="zoom:38%;" />

它的DFS遍历次序是abdehcfg



DFS是一个递归算法,需要借助一个栈,空间复杂度为O(|V|)

按**邻接表的存储方式**,每个结点均需要搜索一次,时间复杂度为O(|v|),在搜索任意顶点的邻接表时,每一条边至少访问一次,时间复杂度为O(|E|),**算法总的时间复杂度为O(|v|+|E|)**

按**邻接矩阵存储方式**,找查每个结点的邻接点所需时间为O(|v|),**算法总的时间复杂度为**



深度优先搜索过程中,我们可以得到一棵遍历树,称为**深度优先生成树**



注:**图的遍历算法可以判断图的连通性**(看遍历完是否访问到所有顶点)





## 3.图的应用

### 3.1最小生成树

**最小生成树:**一个带权连通无向图中,边的权值之和最小的生成树



**最小生成树的性质:**

1. **最小生成树不是唯一的**,当图中各边权值都互不相等时,最小生成树唯一,当图的边数比顶点数少1时,最小生成树就是它本身;
2. **最小生成树的边的权值之和是唯一的且最小**
3. **最小生成树的边数为顶点数减1**



**构造最小生成树的算法**:

1. **prim(普里姆)算法**

   总结:选取某一个顶点,每次寻找与该顶点相关的权值最小边对应的顶点,然后再寻找这两个顶点相关的权值最小的边对应的顶点,不断重复进行,直至顶点全部被联系起来

   时间复杂度为
   $$
   O(|v^2|)
   $$
   其中是顶点的数目,因此时间复杂只与顶点的个数相关,不依赖于边,更适合边稠密图

   <img src="E:\数据结构\image\prim构造最小生成树.png" style="zoom:38%;" />

2. **Kruskal(克鲁斯卡尔)算法**

   总结:每次找到未选取过的权值最小边以及对应的两个顶点,并且要求两个顶点间只有一条路径,直至所有顶点被联系起来

   时间复杂度为:
   $$
   O(|E|log_2|E|)
   $$
   时间复杂度与边相关,因此该算法适合于边稀疏而顶点多的图

   <img src="E:\数据结构\image\Kruskal算法构造最小生成树.png" style="zoom:38%;" />



### 3.2最短路径

1. **Dijkstra算法**

   与prim算法有些类似,基于贪心策略

   总结:先选取某个顶点,然后找到相邻的第二个结点,选取这一轮的最短路径,然后再选取与第二个结点相邻的第三个结点,选取这一轮的最短路径,依次类推

   <img src="E:\数据结构\image\Dijkstra算法实现过程.png" style="zoom:38%;" />

   时间复杂度为
   $$
   O(|v^2|)
   $$
   
2. **Floyd算法**

   基于动态规划策略

   总结:依次选取不同的结点作为中间站,用二维数组将每次的最短路径记录下来

   <img src="E:\数据结构\image\Floyd算法图G.png" alt="3" style="zoom:38%;" />

   <img src="E:\数据结构\image\Floyd算法执行过程图.png" style="zoom:38%;" />

   时间复杂度为
   $$
   O(|v^3|)
   $$
   

### 3.3有向无环图描述表达式

**有向无环图(DAG图)**:不存在环的有向图

例如:<img src="E:\数据结构\image\有向无环图表达式.png" style="zoom:38%;" />

<img src="E:\数据结构\image\有向无环图描述表达式.png" style="zoom:38%;" />

左图是二叉树,右图是有向无环图,相比较下来,**更节省空间**



### 3.4拓扑排序

**AOV网**:用DAG图表示一个工程,其顶点表示活动的网格

**拓扑排序**:在图论中,由一个有向无环图的顶点组成的序列,当前仅当满足以下条件时的图:

1. 每个顶点只出现一次
2. 若顶点A在序列中排在顶点B前面,则在该图中不存在从顶点B到顶点A的路径



拓扑排序的方法:

1. 从AOV网中选择一个没有前驱的顶点并输出
2. 从网中删除该顶点和所有以它为起点的有向边
3. 重复步骤1和2知道当前AOV网为空或当前网中不存在无前驱的顶点为止



拓扑排序的过程:

<img src="E:\数据结构\image\拓扑排序的过程.png" style="zoom:38%;" />

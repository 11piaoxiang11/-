# 第五章 树与二叉树

![](E:\数据结构\image\树与二叉树.png)

## 1.树的基本概念

**树:**n个结点的有限集.树是一种递归的数据结构,树作为一种逻辑结构,同时也是一种分层结构

**树的特点:**

1. 树的根结点没有前驱,除根结点外所有结点有且仅有一个前驱
2. 树中所有结点都可以有零个或多个后继



树的树形表示:

<img src="E:\数据结构\image\树的树形表示.png" style="zoom:38%;" />

例如在图中的结点K中.根A到结点K的唯一路径上的任意结点,称为结点K的**祖先**.就像结点B是结点K的祖先,而结点K是结点B的**子孙**.路径上最接近结点K的结点E是K的**双亲**,而K是E的**孩子**.有相同双亲的结点称为**兄弟**,例如K和L是兄弟



**结点的度:**树中一个结点的孩子个数

**度:**树中结点最大度数

例如:在上图中,B的度数为2,整个树的度数为3



**叶结点:**度为0(没有子女结点)的结点



**结点的层次:**由根节点开始为第一层,子节点为第二层,依次类推

**结点的深度:**同样从根节点开始自顶向下逐层累加

**结点的高度:**是从叶节点开始自底向下逐层累加



**有序树:**树中结点的各子树从左到右是有次序的,不能互换

**无序树:**与有序树相反的树



**路径:**两结点中存在边可达.树中两结点之间的路径是由这两个结点之间所经过的结点序列构成的

**路径长度:**路径上所经过的边的个数

**注:**树中的分支是有向的,是从双亲指向孩子,所以树中的路径是从上到下的,即同一双亲的两个孩子之间不存在路径



**森林**:m棵互不相交的树的集合

**注:**把树的根节点删掉就成了森林,反之给m棵独立的树加上一个结点,并把这m棵树作为该结点的子树,则森林就变成了树



**树的性质:**

1. **树中的结点数等于所有结点的度数之和加1**

   理由如下:由度的定义可知,假设一个结点的度为n意味着这个结点有n个孩子,那么将这些孩子累加就能得到除根结点外所有结点的个数,那么再加上根结点就等于树中的结点数

2. **度为m的树中第i层上至多有**
   $$
   m^{i-1}
   $$
   **个结点**

   理由如下:要使度为m的树中第i层的结点最多,就意味第i-1层上每个结点的度都要最大,即全部为树的度m,它的子结点会最多,即第i层结点数最多,由此类推要实现最大,则使根节点开始每一层按m个结点等比递增,得到等比公式
   $$
   a_i=a_1*q^{i-1}=1*m^{i-1}=m^{i-1}
   $$

3. **高度为h的m叉树至多有**
   $$
   (m^h-1)(m-1)
   $$
   **个结点**

   理由如下:有第2条性质可知每一层最多的结点 ,因此将每一层最多的结点累加起来,由等比数列的累加公式即得

4. **具有n个结点的m叉树的最小高度为**
   $$
   \lceil log_m(n(m-1))+1 \rceil
   $$
   理由如下:由性质3可知
   $$
   (m^h-1)(m-1)=n
   $$
   化简即能得到本公式



### 1.1例题

1.一颗有n个结点的树的所有结点的度数之和为()

答:n-1,由性质1可知



2.度为4,高度为h的树,()

A.至少由h+3个结点	B.至多由4h-1个结点	C.至多有4h个结点	D.至少有h+4个结点



答:A,要使结点最少,即h-1层的结点有4个度,其他结点的度均为最小即为1,所以最小结点数为
$$
(h-1)+4=h+3
$$
即A正确,B,C中带入性质3的公式可得
$$
(m^h-1)(m-1)=3(4^h-1)
$$


3.对于一棵具有n个结点,度为4的树来说,()

A.树的高度至多为n-3	B,树的高度至多为n-4	C.第i层上至多有4(i-1)个结点	D.至少在某一层上正好有4个结点



答:A,在A,B中与上题类似,要高度至多,呢么意味着叶结点的个数等于度数等于4,其他每一层的结点个数均为1,即高度至多有(n-4)加上最后一层,即(n-3),C由性质1可知错误,D中要注意树的度的定义,度为4只意味着某个结点的孩子有4个结点



4.假定一棵度为3的树中,结点树为50,则其最小高度为()

答:5,由性质4可得



## 2.二叉树的概念

### 2.1二叉树的定义及其主要特性

**二叉树的定义**

二叉树:一种特殊的树形结构,**其特点是**每个结点至多只有两个子树,且子树之间有左右之分,不能颠倒

二叉树的五种形态:

<img src="E:\数据结构\image\二叉树的五种形态.png" style="zoom:38%;" />



**特殊二叉树:**

1. **满二叉树**

   一棵高度为h,且含有
   $$
   2^h-1
   $$
   个结点的二叉树,如图所示:

   <img src="E:\数据结构\image\满二叉树.png" style="zoom:38%;" />

2. **完全二叉树**

   高度为h,有n个结点的二叉树,当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应,如图所示:

   <img src="E:\数据结构\image\完全二叉树.png" style="zoom:38%;" />

   **完全二叉树的特点:**

   (1)若
   $$
   i\leq\lfloor n/2 \rfloor
   $$
   则结点i是分支结点或者是叶结点

   (2)叶节点只会在层次最大的两层出现

   (3)若度为1的结点有且仅有一个,那该结点只有左孩子无右孩子
   (4)按层序编号后,一旦出现某结点i只有左孩子或者是叶节点时,则编号大于i的结点均为叶结点

   

   **完全二叉树的性质:**

   (1)当i>1时,i为偶数时,它的双亲编号为i/2,它为左孩子,i为奇数时,它的双亲编号为(i-1)/2,它为右孩子

   (2)当2i<=n时,结点i的左孩子为2i,当2i+1<=n时,结点i的右孩子为2i+1

   (3)结点i所在的深度为
   $$
   \lfloor log_2i \rfloor+1
   $$

3. **二叉排序树**:左子树上所有结点的关键字均小于根结点的关键字;右子树所有结点的关键字均大于根结点的关键字,其左右子树又格式一颗二叉排序树

4. **平衡二叉树:**树上任意一个结点的左子树和右子树深度之差不超过1



**二叉树的性质:**

1. (**重要**)非空二叉树上的叶结点数等于度为2的结点数加1,即
   $$
   n_0=n_2+1
   $$
   证明如下:设度为0,1和2的结点个数均为
   $$
   n_0,n_1,n_2
   $$
   结点总数为
   $$
   n=n_0+n_1+n_2
   $$
   设二叉树的分支总数为B,不难发现:
   $$
   n=B+1
   $$
   而在分支总数中,度为1的结点提供对应的一个分支,度为2的结点提供对应的两个分支,即
   $$
   B=n_1+2n_2
   $$
   联立即得

2. (**重要**)非空二叉树上第k层上至多有
   $$
   2^{k-1}
   $$
   个结点,与树的性质2相同

3. (**重要**)高度为h的二叉树至多有
   $$
   2^h-1
   $$
   个结点,与树的性质3相同



### 2.2二叉树的存储结构

#### 2.2.1二叉树的顺序存储结构

**二叉树的顺序存储结构**:用一组地址连续的存储单元依次自上向下,自左到右存储完全二叉树的结点元素

完全二叉树和满二叉树更适合采用顺序存储



用数组下标反应二叉树中结点之间的逻辑关系:

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" style="zoom:38%;" />

注:一般从数组下标1开始存储树中的结点



#### 2.2.2二叉树的链式存储结构

由于顺序存储结构空间利用率较低,因此我们多使用链式存储结构

在链式存储结构中,我们通常用二叉链表来表示:数据域(Data),左指针域(lchild),右指针域(rchild)

```cpp
typedef struct BiTNode{
	ElemType data;
	struct BiTNode* lchild,*rchild;
}BiTNode,*BiTree;
```



<img src="E:\数据结构\image\二叉树的链式存储结构.png" style="zoom:38%;" />



## 3.二叉树的遍历与线索二叉树

**二叉树的遍历:**按某条搜索路径访问树中每个结点,使得每个结点均被访问一次,而且仅被访问一次



### 3.1先序遍历(根->左->右)

**先序遍历的操作过程:**

1. 访问根节点
2. 先序遍历左子树
3. 先序遍历右子树



```cpp
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);//访问根结点
		PreOrder(T->lchild);
		PreOrder(T->rchild);
	}
}
```



### 3.2中序遍历(左->根->右)

**中序遍历的操作过程**:

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树



```cpp
void InOrder(BiTree T){
	if(T!=NULL){
		InOrder(T->lchild);
		visit(T);
		InOrder(T->rchild);
	}
}
```



### 3.3后序遍历(左->右->根)

**后序遍历的操作过程:**

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根结点



```cpp
void PostOrder(BiTree T){
	if(T!=NULL){
		PostOrder(T->lchild);
		PostOrder(T->rchild);
		visit(T);
	}
}
```



### 3.4先,中,后三种遍历方式的总结

三种遍历方式,都是递归遍历左右子树,但访问根结点的顺序不同

三种遍历方式,每个结点均只访问一次,因此**时间复杂度为O(n)**,递归工作**栈的深度为树的深度**,最坏情况下是,有n个结点且深度为n的单支树



非递归版本,借助栈来遍历:

以中序遍历为例

```cpp
void InOrder2(BiTree T){
	InitStack(S);//初始化栈
	BiTree p=T;//p是遍历指针
	while(p||!IsEmpty(S)){//若栈不空或p所指的结点不空
		if(p){//如果p所指结点不空,一路向左
			Push(S,p);//当前结点入栈
			p=p->lchild;//向左走
		}else{
			Pop(S,p);//栈顶元素出栈
			visit(p);//访问出栈结点
			p=p->rchild;//向右走
		}
	}
}
```



遍历该图的次序:

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" alt="3" style="zoom:38%;" />

先序遍历的次序是?  

答:

1. 先访问根,即1;
2. 然后访问1的左子树,访问左子树的根,即2;
3. 访问2的左子树,但左子树不存在,访问2的右子树,访问右子树的根,即4
4. 访问4的左子树,即6
5. 再访问4的右子树不存在,发现1左子树的所有结点均访问完毕,访问1的右子树的根,即3
6. 访问3的左子树不存在,然后访问3的右子树,即5
7. 所以最后顺序是1,2,4,6,3,5





中序遍历的次序是?

答:

1. 先访问1的左子树是以2为根;
2. 再访问2的左子树,不存在,访问2这个子树的结点,即2;
3. 访问2的右子树是以4为根,访问4的左子树,即6;
4. 访问4这个子树的根结点,即4;
5. 访问4的右子树,不存在;
6. 发现1的左子树遍历完毕,访问1的根,即1
7. 访问1的右子树.....
8. 最后的顺序是2,6,4,1,3,5





后序遍历的次序是?

答:6,4,2,5,3,1



### 3.5层序遍历

需要借助一个队列,与之后的广度优先搜索算法类似

遍历次序便是从左到右,从上到下遍历结点

像上图的遍历次序是:1,2,3,4,5,6



注:二叉排序树,利用层序遍历,逆层序遍历就能得到升序和降序



```cpp
void LevelOrder(BiTree T){
	InitQueue(Q);//初始化辅助队列
	BiTree p;
	EnQueue(Q,T)//根节点入队
	while(!IsEmpty(Q)){//如果队列不空
		DeQueue(Q,p);//出队
		visit(p);//访问出队结点
		if(p->lchild!=NULL) EnQueue(Q,p->lchild);//如果左子树不空,将左子树根加进队列
		if(p->rchild!=NULL) EnQueue(Q,p->rchild);//如果右子树不空,将右子树根加进队列
	}
}
```



### 3.6由遍历序列构造二叉树

已知遍历序列是能构造出二叉树的,但有一定条件限制:

由之前的二叉树遍历次序,可知

<img src="E:\数据结构\image\二叉树的顺序存储结构.png" style="zoom:38%;" />

先序遍历:1,2,4,6,3,5

中序遍历:2,6,4,1,3,5

后序遍历:6,4,2,5,3,1



发现:

**在先序遍历中**,第一个结点一定是根结点,后序结点是左右子树的序列

**在后序遍历中**,最后一个结点一定是根结点,前面结点是左右子树的序列

我们单独根据先序遍历和后序遍历是无法弄清后序左右子树的排列顺序

**在中序遍历中**,根节点必然将整个序列分割成左右子树序列

中序遍历的特点正好弥补了先序和后序中未知左右子树排列顺序的缺点

因此,**只要已知先序遍历和后序遍历的其中一个序列,再已知中序遍历序列,就能构造出二叉树**



注:**一定会需要中序遍历**



例如已知先序(ABCDEFGHI),中序(BCAEDGHFI)

<img src="E:\数据结构\image\已知序列构造二叉树.png" style="zoom:38%;" />



### 3.7线索二叉树

在传统二叉树中,某一些结点只有左孩子而没有右孩子(也有可能相反),因此会空余出来相应的指针域,为了充分利用这些指针域(空间),我们构造了线索二叉树,将这些指针域用于存放指向前驱和后继的指针

**引入线索二叉树的目的:**节省空间,加快查找结点前驱和后继的速度



**线索二叉树的规定:**若无左子树,令lchild指向其前驱结点,若无右子树,令rchild指向后继结点.同时我们增加了两个标志域标识指针域

如图所示:

<img src="E:\数据结构\image\线索二叉树的结点结构.png" style="zoom:38%;" />

其标志域的含义为:

当ltag为0时表示lchild指向的是左孩子,ltag=1时,表示的是lchild指向的是前驱

当rtag为0时表示rchild指向的是右孩子,rtag=1时,表示的是rchild指向的是后继



```cpp
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode* lchild,*rchild;
	int ltag,rtag;
}TreadNOde,*TreadTree;
```



#### 3.7.1中序线索二叉树的构造

<img src="E:\数据结构\image\中序线索二叉树及其二叉链的表示.png" style="zoom:38%;" />

已知如图所示的二叉树,通过中序遍历得到序列为:B,D,A,E,C

发现B没有左子树,也没有前驱,因此不需要线索化,同理C,没有右子树,没有后继,不需要线索化

D没有左子树,前驱是B,所以D的lchild指向B,D没有右子树,后继是A,所以D的rchild指向A

E同理



中序遍历的二叉树线索化算法:

```cpp
void InThread(ThreadTree &p,ThreadTree &pre){
	if(p!=NULL){
		InThread(p->lchild,pre);//递归,线索化左子树
		if(p->lchild==NULL){//如果左子树为空
			p->lchild=pre;//指向前驱
			p->ltag=1;//刷新标志域
		}
		if(pre!=NULL&&pre->rchild==NULL){//如果右子树为空
			pre->rchild=p;//指向后继
			pre->rtag=1;//刷新标志域
		}
	}
}
```



中序遍历建立中序线索二叉树的主过程算法如下:

```cpp
void CreateInThread(ThreadTree T){
	ThreadTree pre=NULL;
	if(T!=NULL){//非空二叉树,线索化
		InThread(T,pre); //线索化
		pre->rchild=NULL;//处理遍历的最后一个结点
		pre->rtag=1;
	}
}
```



#### 3.7.2中序二叉树的遍历

求中序线索二叉树的第一个结点:

```cpp
TreadNode *FirstNode(ThreadNode *p){
	while(p->ltag==0) p=p->lchild;
	return p;
}
```



求中序线索二叉树结点p在中序序列下的后继:

```cpp
ThreadNode* Nextnode(ThreadNode* p){
	if(p->rtag==0) return FirstNode(p->rchild);
	else return p->rchlid;
}
```



#### 3.7.3先序线索二叉树和后序线索二叉树

根据遍历次序决定前驱和后继

后序线索二叉树较为复杂,可以用带标志域的三叉链表作为存储结构



## 4.树和森林

### 4.1树的存储结构

1. **双亲表示法**

​		利用一组连续空间来存储每个结点,同时在每个结点增设一个伪指针指向双亲结点所在的位置

<img src="E:\数据结构\image\双亲表示法.png" style="zoom:38%;" />



```cpp
#define MAX_TREE_SIZE 100 //树中最多结点数
typedef struct{
	ElemType data;//数据元素
	int parent;//双亲位置域
}PTNode;
typedef struct{
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int n;//结点数
}PTree;
```

优点:可以很快的得到结点的双亲结点

缺点:求结点的孩子需要遍历整个结构



​	2.**孩子表示法**

将每个结点的孩子结点都用单链表连接起来,形成一个线性结构,此时n个结点就有n个孩子链表

<img src="E:\数据结构\image\孩子表示法.png" style="zoom:38%;" />

优点:能够快速找到孩子结点

缺点:找结点的双亲时需遍历整个数组

​	

​	3.**孩子兄弟表示法(二叉树表示法)**

用二叉链表作为树的存储结构,每个结点包括三部分:结点值,指向结点的第一个孩子的指针,指向结点下一个兄弟结点的指针

```cpp
typedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

优点:可以方便的实现树转化为二叉树的操作,易于找查结点的孩子

缺点:找查双亲比较麻烦

若每个结点增设一个parent域指向父结点,则找查父结点也将变得方便

<img src="E:\数据结构\image\孩子兄弟表示法.png" style="zoom:38%;" />



### 4.2树,森林和二叉树的转换

树转换为二叉树的规则:**左孩子右兄弟**,将每个结点的左指针指向它的第一个孩子,右指针指向它在树中相邻的右兄弟

注:由于根结点没有兄弟,所以对应的二叉树没有右子树

<img src="E:\数据结构\image\树转化成二叉树.png" style="zoom:38%;" />

森林转化成二叉树与之类似,将每个根节点看作兄弟,**一样执行左孩子右兄弟原则**

<img src="E:\数据结构\image\森林转化成二叉树.png" style="zoom:38%;" />



### 4.3树和森林的遍历

树的遍历方式:

1. **先根遍历:**若树非空,先访问根结点,再一次访问根结点的每个子树,然后同理遍历子树,其遍历次序与对应二叉树的先序遍历次序相同
2. **后根遍历:**若树非空,先遍历根节点的每个子树,再访问根节点,同理遍历子树,其遍历次序与对应的二叉树中序遍历相同



森林的遍历方式:

1. 先序遍历森林
   - 访问森林中第一棵树的根结点
   - 先序遍历第一棵树中根结点的子树森林
   - 先序遍历出去第一棵树之后剩余的树构成的森林
2. 中序遍历森林
   - 中序遍历森林中第一棵树的根结点的子树森林
   - 访问第一棵树的根结点
   - 中序遍历除去第一棵树之后剩余的树构成的森林



## 5.树和二叉树的应用

### 5.1哈夫曼树和哈夫曼编码

**哈夫曼树的定义**

**权:**树中结点被赋予表示某种意义的数值

**结点的带权路径长度:**从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积

**树的带权路径长度:**树中所有叶结点的带权路径长度之和,记为
$$
WPL=\sum^n_{i=1}w_il_i
$$
**哈夫曼树(最优二叉树):**在含有n个带权叶结点的二叉树中,WPL最小的二叉树

<img src="E:\数据结构\image\哈夫曼树.png" style="zoom:38%;" />



**哈夫曼树的构造**

1. 构造一个新结点
2. 在n个结点中找出权值最小的两个结点,分别作为新结点的左右子树,并将两个结点的权值之和赋值给新结点
3. 把新结点并入原来剩下的结点中,重复操作,直至剩下的结点数为0

<img src="E:\数据结构\image\哈夫曼树的构造.png" style="zoom:38%;" />

**哈夫曼编码**

**固定长度编码:**每个字符用相等长度的二进制位来表示

**可变长度编码:**允许对不同字符用不等长的二进制位表示



**可变长度编码相对固定长度编码的特点:**对频率高的字符赋以短编码,而频率低的赋以长编码,从而减少平均编码长度,起到压缩的效果



**前缀编码:**若没有一个编码是另一个编码的前缀

前缀编码是为了避免二义性,例如,假设A的编码是0,B的编码是00,输入00编码,无法识别它是两个A还是一个B



**哈夫曼编码**:根据哈夫曼树中结点权值出现的比例,对结点权值进行的编码

一般情况下,层数越小越容易出现比较,因此哈夫曼编码的大小随着层数的递增而递增



### 5.2并查集

**并查集**:用于处理一些不相交集合的合并及查询问题（即所谓的并、查）的树结构

一般用树的双亲表示法作为存储结构



并查集的结构:

```cpp
#define SIZE 100
int UFSets[SIZE];//集合元素数组
```

初始化操作:

```cpp
void Initial(int S[]){
	for(int i=0;i<SIZE;i++){
		S[i]=-1;
	}
}
```

Find操作:

```cpp
int Find(int S[],int x){
	while(S[x]>=0) x=S[x];
	return x;
}
```

Union操作:

```cpp
void Union(int S[],int Root1,int Root2){
	if(Root1==Root2) return;
	S[Root2]=Root1;
}
```


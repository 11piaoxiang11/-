# 第七章 查找

<img src="E:\数据结构\image\查找.png" style="zoom:38%;" />

## 1.查找的基本概念

**查找**:在数据集合中寻找满足某种条件的数据元素的过程

**查找表**:用于查找数据的集合

**静态查找表**:如果一个查找表的操作不会修改该查找表(例如查询,检索,但插入和删除就不满足)的查找表

**关键字**:数据元素中唯一表示该元素的某个数据项的值

**平均查找长度:**所有查找过程中进行关键字比较次数的平均值



## 2.顺序查找和折半查找

### 2.1顺序查找

**顺序查找(线性查找)**:顺序扫描每个元素



**一般顺序表的顺序查找**:

```cpp
typedef struct{
	ElemType *elem;
	int TableLen;
}SSTable;

int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;
    for(int i=ST.TableLen;ST.elem[i]!=key;--i)//从后往前找
    return i;//返回索引位置
}
```



顺序查找的平均长度为
$$
ASL_{成功}=\sum^n_{i=1}p_i(n-i-1)=(n-1)/2
$$
查找不成功为n+1



顺序查找的优点:对数据元素的存储没有要求,顺序存储和链式存储皆可.对表中记录的有序性没有要求

顺序查找的缺点:当n较大时,平局一年查找长度较大,效率低



**有序表的顺序查找:**

若在查找之前已知表中关键字有序,则查找失败可以不用比较到表的另一端就能返回查找失败的信息,从而降低顺序查找事变的平均查找长度

例如已知表L关键字从小到大排序,查找关键字key,当查找到第i个元素时,发现第i个元素对应的关键字小于key,但第i+1个关键字大于key,则返回表中不存在关键字key的元素



### 2.2折半查找(二分查找)

**适用条件:**有序的顺序表

**思想**:先将给定的值key于表中中间位置的元素比较,若相等,则查找成功返回该元素的位置,若不等所查找的元素只能在中间元素外的前半部分或后半部分,然后缩小范围继续同样的查找



```cpp
int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.TableTen-1,mid;
    while(low<=high){
        mid=(low+high)/2;
        if(L.elem[mid]==key) return mid;
        else if(L.elem[mid]>key) high=mid-1
        else low=mid+1;
    }
	return -1;
}
```



平均查找长度:
$$
ASL=log_2(n+1)-1
$$




### 2.3分块查找(索引顺序查找)

**思想**:将查找表分成若干块,块内元素可以无序,但块间元素是有序的,即第一个块中的最大关键字小于第二个块中所有记录的关键字,一次类推,再建立索引表,索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址,索引表按关键字有序排列

分块查找的过程:

1. 再索引表中确定待查记录所在的块,可以顺序查找或折半查找索引表
2. 在块内顺序查找

<img src="E:\数据结构\image\分块查找.png" style="zoom:38%;" />





## 3.树形查找

### 3.1二叉排序树(BST)

构造二叉排序树的目的并不是为了排序,而是为了提高查找,插入和删除关键字的效率



**二叉排序树**:具有以下特性的二叉树:

1. 若左子树非空,则左子树上所有结点的值均小于根结点的值
2. 若右子树非空,则右子树上所有结点的值均大于根结点的值
3. 左右子树也分别是一棵二叉排序树

总结:
$$
左子树<根结点<右子树
$$
**二叉排序树的查找**:

先从根结点开始,沿分支逐层向下比较

```cpp
BSTNode *BST_Search(BiTree T,ElemType key){
    while(T!=NULL&&key!=T->data){
        if(key<T->data) T=T->lchild;
        else T=T->rchild;
    }
    return T;
}
```



**二叉排序树的插入:**

若原二叉排序树为空,则直接插入,否则若关键字key小于根结点值,则插入到左子树,若key大于根结点的值则插入到右子树.插入的结点一定是一个新添加的叶结点,且是查找失败时查找路径上访问的最后一个结点的左孩子或右孩子

```cpp
int BST_Insert(BiTree &T,KeyType k){
	if(T==NULL){
		T=(BiTree)malloc(sizeof(BSTNode));
        T->data=k;
        T->lchild=T->child=NULL;
        return 1;
	}else if(k==T->data) return 0;
    else if(k<T->data) return BST_Insert(T->lchild,k);
    else return BST_Insert(T->rchild,k);
}
```



**二叉排序树的构造:**

```cpp
void Creat_BST(BiTree &T,KeyType str[],int n){
	T=NULL;
    int i=0;
    while(i<n){
        BST_Insert(T,str[i]);
        i++
    }
}
```



**二叉排序树的删除:**

在二叉排序树中删除一个结点时,不能把以该结点为根的子树上的结点都删除,必须先把被删除结点从存储二叉排序树的链表上摘下,将因删除结点而断开的二叉链表重新连接起来,同时确保二叉排序树的性质不会丢失

删除操作的三种情况:

1. 若删除结点z是叶结点则直接删除
2. 若结点z只有一颗左子树或右子树,则让z的子树称为z父结点的子树,替代z的位置
3. 若z有两颗子树,则令z的直接后继(或直接前驱)替代z,然后从二叉排序树中删除这个直接后继,这样就转换成了第一或第二种情况



### 3.2平衡二叉树(AVL)

**平衡二叉树:**在二叉树种任意结点的左右子树高度差不超过1

**目的:**避免树的高度增长过快,降低二叉排序树的性能

**平衡因子:**定义结点左子树与右子树的高度差

平衡二叉树的平衡因子只可能是-1,0,1



**平衡二叉树的插入:**

插入结点后,调整各结点的位置关系,使之重新达到平衡



插入的四种调整情况:

1. LL平衡旋转(右单旋转):在结点A的左孩子(L)的左子树(L)上插入新结点,让以A为根的整棵子树右上旋转

   <img src="E:\数据结构\image\LL平衡旋转.png" style="zoom:38%;" />

2. RR平衡旋转(左单旋转):在结点A的右孩子(R)的右子树(R)上插入新结点,让以A为根的整棵子树左上旋转

   <img src="E:\数据结构\image\RR平衡旋转.png" style="zoom:38%;" />

3. LR平衡旋转(先左后右双旋转):在结点A的左孩子(L)的右子树(R)上插入新结点,先左旋再右旋

   <img src="E:\数据结构\image\LR平衡旋转.png" style="zoom:38%;" />

4. RL平衡旋转(先右后左双旋转):在结点A的右孩子(R)的左子树(L)上插入新结点,先右旋再左旋

   <img src="E:\数据结构\image\RL平衡旋转.png" style="zoom:38%;" />

   

   

**平衡二叉树的删除**与上述规则类似

**平衡二叉树的查找**平均长度为O(log2n)





## 4.B树和B+树

### 4.1B树及其基本操作

**m阶B树:**满足以下特性的m叉树:

1. 树中每个结点至多有m棵子树,即至多含有m-1个关键字

2. 若根结点不是叶结点,则至少有两棵子树

3. 若除根结点外所有非叶结点至少含有
   $$
   \lceil m/2 \rceil
   $$
   棵子树,即至少含有
   $$
   \lceil m/2 \rceil-1
   $$
   个关键字

​                   

<img src="E:\数据结构\image\B树的实例.png" style="zoom:38%;" />

**B树的高度(磁盘存取次数)**

<img src="E:\数据结构\image\B树的高度.png" style="zoom:38%;" />

**B树的查找**

<img src="E:\数据结构\image\B树的查找.png" style="zoom:38%;" />

**B树的插入**

<img src="E:\数据结构\image\B树的插入.png" style="zoom:38%;" />

**B树的删除**

<img src="E:\数据结构\image\B树的删除.png" style="zoom:38%;" />

### 4.2B+树的基本概念

B+树是应数据库所需的一种B树的变形树



## 5.散列表(哈希表)

### 5.1散列表的基本概念

**散列函数:**一个把查找表中的关键字映射成该关键字对应的地址的函数,记为Hash(key)=Addr

**冲突:**散列函数可能会把两个或两个以上的不同关键字映射到同一地址

**同义词:**发生碰撞的不同关键字

**散列表:**根据关键字而直接进行访问的数据结构,也就是说散列表建立了关键字和存储地址之间的一种直接映射关系

理想情况下,对散列表进行查找的时间复杂度为O(1)



### 5.2散列函数的构造方法

构造时的注意事项:

1. 散列函数的定义域必须包含全部需要存储的关键字,而值域范围则依赖于散列表的大小或地址范围
2. 散列函数计算出来的地址应该等概率,均匀地分布在整个地址空间中,从而减少冲突的发生
3. 散列函数应该尽量简单,能够在较短时间内计算出任意关键字对应的散列地址



1.**直接定址法**

直接取关键字的某个线性函数值为散列地址,散列函数为
$$
H(key)=key或H(key)=a*key+b
$$
2.**除留余数法**

最常见,最简单的方法

假定散列表长为m,取一个不大于m但最接近或等于m的质数p,利用以下公式把关键字转换成散列地址,散列函数为
$$
H(key)=key \% p
$$
3.**数字分析法**

设关键字是r进制数,而r个数码在各位出现的频率不一定相同,可能会在某些位上分布均匀一些,每种数码出现的机会均等,而在某些位上分布不均匀,只有某几种数码经常出现,此时应选取数码分布较为均匀的若干位作为散列地址,此方法适合于已知关键字集合,若更换了关键字需要重新构造新的散列函数

4.**平方取中法**

取关键字的平方中间几位作为散列地址



**处理冲突的方法:**

1. **开放地址法**

   **开放地址法:**可存放新表项的空闲地址既向它的同义词表项开放,又向非同义词表项开放,其数学递推公式为
   $$
   H_i=(H(key)+d_i)\%m
   $$
   H(key)为散列函数,m为表长,d为增量序列

   取定增量序列的方法:

   1. 线性探测法
   2. 平方探测法
   3. 双散列法
   4. 伪随机序列法

2. **拉链法**

   将所有同义词存储在一个线性链表中,这个线性链表由其其散列地址唯一标识



### 5.3散列查找的性能分析

散列表的查找效率取决于三个因素:散列函数,处理冲突的方法和装填因子

装填因子
$$
\alpha=表中记录数n/散列表的长度m
$$
散列表的平均查找长度依赖于装填因子,不直接依赖于n或m
